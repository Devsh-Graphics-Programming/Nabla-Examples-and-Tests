#version 450 core

//place for #defines to put with sprintf
%s

#if 0
#extension GL_NV_compute_shader_derivatives : enable
#if defined(GL_NV_compute_shader_derivatives)
layout (derivative_group_quadsNV) in;

#define IRR_DDX_IS_DEFINED 1
#define IRR_DDY_IS_DEFINED 1

float DDX(in float x)
{
	return dFdx(x);
}

float DDY(in float y)
{
	return dFdy(x);
}
#else	
	#extension GL_KHR_shader_subgroup_clustered : enable
	#extension GL_KHR_shader_subgroup_basic : enable
	#if defined(GL_KHR_shader_subgroup_clustered) && defined(GL_KHR_shader_subgroup_basic)
	
	#define IRR_DDX_IS_DEFINED 1
	// WARNING: No DDY here! Tpose and use DDX().

	float DDX(in float x)
	{
		// The extension is supported but i'm getting "error: unknown builtin varying (named gl_SubgroupInvocationID) encountered" (?!?!?!?!?!)
		int xormask = int((~gl_SubgroupInvocationID) << 31);
		int fbits = floatBitsToInt(x);
		// branchless sign swap of elements on even positions so that we get dx = (-[i])+[i+1] = [i+1]-[i]
		return subgroupClusteredAdd(intBitsToFloat(fbits ^ xormask), 2);
	}
	#endif
#endif
#endif //#if 0 
//possible use of extensions is turned off for now because untested due to:
//1) my GTX660 doesn't support GL_NV_compute_shader_derivatives (actually seems like only high-end RTXs support this)
//2) weird error "unknown builtin varying" concerning gl_SubgroupInvocationID even though GL_KHR_shader_subgroup_clustered is supported (driver bug?)

// also distribution of work-groups on dimensions should depend on available GLSL extensions
#if defined(IRR_DDX_IS_DEFINED) && defined(IRR_DDY_IS_DEFINED)
layout (local_size_x = 16, local_size_y = 16) in;
#else
	#if XPASS
	layout (local_size_x = 256) in;
	#else
	layout (local_size_y = 256) in;
	#endif
#endif

#if !defined(IRR_DDX_IS_DEFINED) && !defined(IRR_DDY_IS_DEFINED)
shared float smem[256]; //1KB
#endif

layout (binding = 7) uniform sampler2D bumpMapSampler;
#if !defined(IRR_DDY_IS_DEFINED)
layout (binding = 0, r16_snorm) uniform image2D derivativeMapImage;
#else
layout (binding = 0, rg16_snorm) uniform image2D derivativeMapImage;
#endif

layout (location = 0) uniform float uHeightScaleFactor = 0.1;

void main()
{
	const ivec2 G_IDX = ivec2(gl_GlobalInvocationID.xy);
	const ivec2 RESOLUTION = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
	
#if defined(IRR_DDX_IS_DEFINED) && defined(IRR_DDY_IS_DEFINED)
	float smpl = textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX), 0.0).r * uHeightScaleFactor;
	float dx = DDX(smpl);
	float dy = DDY(smpl);
	
	if ((G_IDX.x & 1) == 0 && (G_IDX.y & 1) == 0)
		imageStore(derivativeMapImage, G_IDX/2, vec4(dx, dy, 0.0, 0.0));
#elif defined(IRR_DDX_IS_DEFINED)
	float d = DDX(textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX), 0.0).r * uHeightScaleFactor);
	if ((G_IDX.x & 1) == 0 && (G_IDX.y & 1) == 0)
		imageStore(derivativeMapImage, G_IDX/2, vec4(d, 0.0, 0.0, 0.0));
#else
	const uint LC_IDX = gl_LocalInvocationIndex;
	smem[LC_IDX] = textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX), 0.0).r * uHeightScaleFactor;
	
	barrier(); // AFAIK execution barrier implies memory barrier
	
	const uint SMEM_IDX = LC_IDX/2u * 2u;
	float d = smem[SMEM_IDX+1u] - smem[SMEM_IDX];
	if ((G_IDX.x & 1) == 0 && (G_IDX.y & 1) == 0)
		imageStore(derivativeMapImage, G_IDX/2, vec4(d, 0.0, 0.0, 0.0));
#endif
}