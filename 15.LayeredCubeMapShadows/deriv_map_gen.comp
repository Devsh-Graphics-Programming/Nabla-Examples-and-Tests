#version 450 core

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 7) uniform sampler2D bumpMapSampler;
layout (binding = 0, rg16_snorm) uniform image2D derivativeMapImage;

layout (location = 0) uniform float uHeightScaleFactor = 0.001;

shared float smem[324];//18*18

int getAddr(in ivec2 threadID)
{
	//return 18*threadID.y + threadID.x+1;
	return int(dot(ivec2(1, 18), ivec2(threadID)+ivec2(1, 0)));
}

void main()
{
	const ivec2 G_IDX = ivec2(gl_GlobalInvocationID.xy);
	const ivec2 RESOLUTION = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
	
	vec2 bumpMapSz = vec2(textureSize(bumpMapSampler, 0));

	const ivec2 LC_IDX = ivec2(gl_LocalInvocationID.xy);
	smem[getAddr(LC_IDX)] = textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX), 0.0).r * uHeightScaleFactor;
	if (LC_IDX.x == 0)
		smem[getAddr(LC_IDX-ivec2(1, 0))] = textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX-ivec2(1, 0)), 0.0).r * uHeightScaleFactor;
	if (LC_IDX.x == 15)
		smem[getAddr(LC_IDX+ivec2(1, 0))] = textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX+ivec2(1, 0)), 0.0).r * uHeightScaleFactor;
	if (LC_IDX.y == 0)
		smem[getAddr(LC_IDX-ivec2(0, 1))] = textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX-ivec2(0, 1)), 0.0).r * uHeightScaleFactor;
	if (LC_IDX.y == 15)
		smem[getAddr(LC_IDX+ivec2(0, 1))] = textureLod(bumpMapSampler, vec2(1.0, 1.0)/vec2(RESOLUTION) * vec2(G_IDX+ivec2(0, 1)), 0.0).r * uHeightScaleFactor;
	
	barrier(); // AFAIK execution barrier implies memory barrier
	
	vec2 d = vec2(
		smem[getAddr(LC_IDX+ivec2(1, 0))] - smem[getAddr(LC_IDX-ivec2(1, 0))],
		smem[getAddr(LC_IDX+ivec2(0, 1))] - smem[getAddr(LC_IDX-ivec2(0, 1))]
	) * bumpMapSz;
	
	imageStore(derivativeMapImage, G_IDX, vec4(d, 0.0, 0.0));
}