#version 430 core

#include "shaderCommon.glsl"

layout(local_size_x = kOptimalWorkgroupSize) in;

/*
layout(set = 0, binding = 0, std430) restrict readonly buffer Models
{
    ModelData_t models[];
};
layout(set = 0, binding = 1, std430, row_major) restrict readonly buffer Objects
{
    SceneNode_t objects[];
};

layout(set = 1, binding = 0, std430) restrict coherent buffer VisibleObjectCounter
{
    uint visibleObjectCount;
};
layout(set = 1, binding = 1, std430, row_major) restrict writeonly buffer VisibleObjects
{
    VisibleObject_t visibleObjects[];
};

layout(set = 2, binding = 0, std430, row_major) uniform Cameras
{
    // NOTE: could be an array of `Camera_t` and we could use `gl_GlobalInvocationID.y` to index cameras (or subdivide the X dimension of a workgroup)
    mat4 viewProjMatrix;
    mat4 viewProjMatrixInverse;
    vec3 cameraPosition;
} camera;*/
layout(set = 2, binding = 0, std430) restrict readonly buffer InMultiDrawIndirectCommandBuffer
{
    uint data[];
} inMultiDrawIndirectCommandBuffer;
layout(set = 2, binding = 1, std430) restrict writeonly buffer OutMultiDrawIndirectCommandBuffer
{
    uint data[];
} outMultiDrawIndirectCommandBuffer;


layout(push_constant) uniform PushConstants
{
    uint drawDataArrayDWORDSize;
} pc;


void main()
{
    uint dword = gl_GlobalInvocationID.x;
    if (dword<pc.drawDataArrayDWORDSize)
        outMultiDrawIndirectCommandBuffer.data[dword] = inMultiDrawIndirectCommandBuffer.drawData[dword];

    // TODO: sort by cameraID and meshUUID?
}
