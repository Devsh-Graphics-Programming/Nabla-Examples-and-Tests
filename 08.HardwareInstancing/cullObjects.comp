#version 430 core

#include "shaderCommon.glsl"

layout(local_size_x = kOptimalWorkgroupSize) in;


layout(set = 0, binding = 0, std430, row_major) restrict readonly buffer Objects
{
    SceneNode_t objects[];
};
layout(set = 0, binding = 1, std430) restrict readonly buffer Models
{
    ModelData_t models[];
};
// TODO: Mesh SSBO here
// TODO: MeshBuffer SSBO here
// TODO: MeshBuffer Indirect Draw SSBO here

layout(set = 1, binding = 0, std430) restrict coherent buffer VisibleObjectCounter
{
    uint visibleObjectCount;
};
layout(set = 1, binding = 1, std430, row_major) restrict writeonly buffer VisibleObjects
{
    VisibleObject_t visibleObjects[];
};

layout(set = 2, binding = 0, std430, row_major) uniform Cameras
{
    // NOTE: could be an array of `Camera_t` and we could use `gl_GlobalInvocationID.y` to index cameras (or subdivide the X dimension of a workgroup)
    mat4 viewProjMatrix;
    mat4 viewProjMatrixInverse;
    vec3 cameraPosition;
    // TODO clear the MDI arrays for cameras in this dispatch
    uint dwordMDIOffset;
} camera;
layout(set = 2, binding = 1, std430) restrict readonly buffer ObjectIndexBuffer
{
    uint objectUUIDs[];
};


layout(push_constant) uniform PushConstants
{
    uint objectCount;
} pc;


void main()
{
    if (gl_GlobalInvocationID.x>=pc.objectCount)
        return;

    const uint objectUUID = objectUUIDs[gl_GlobalInvocationID.x];
    const SceneNode_t obj = objects[objectUUID]; // TODO: handle and test irr_builtin_glsl_workaround_AMD_broken_row_major_qualifier
    
    const uint modelUUID = 0u;
    mat4 worldMatrix = obj.worldTransform; 

    mat4 modelViewProjectionMatrix = irr_glsl_pseudoMul4x4with4x3(camera.viewProjMatrix,worldMatrix);
    mat2x3 bbox;
    bbox[0] = models[modelUUID].MinEdge;
    bbox[1] = models[modelUUID].MaxEdge;
    
    int lod = kMaxLoDLevels;
    if (irr_glsl_couldBeVisible(modelViewProjectionMatrix,bbox))
    {
        // Somewhere around here we could add occlusion culling (if we had camera Z-Buffer)

    	const vec3 toCamera = camera.cameraPosition-worldMatrix[3];
    	const float distanceSq = dot(toCamera,toCamera);

        for (int i=0; i<kMaxLoDLevels; i++)
        if (distanceSq<models[modelUUID].LoDDistancesSq[i])
        {
            lod = i;
            //break; // TODO: breaks or improves performance?
        }
    }
    
    const bool notCulled = lod<kMaxLoDLevels;
    uint outputIndex;
    // TODO: could optimize the reduction
    /*
    shared uint scratch[kOptimalWorkgroupSize/4u];

    // a boolean inclusive prefix sum
    const uint localOffsetPlus1 = irr_glsl_workgroupScanAddInclusive_scratch(notCulled);
    if (gl_LocalInvocationIndex == gl_WorkGroupSize-1u)
        scratch[0u] = atomicAdd(visibleObjectCount,localOffsetPlus1);
    barrier();
    outputIndex = scratch[0u]+localOffsetPlus1-1u;
    

    // irr_glsl_workgroupScanAddInclusive_scratch(in bool cond) could be implemented like this
        const uint notCulledBallot = ballot(cond); // I hope ballot implies subgroupBarrier
        const uint localInclPrefix = bitcount(notCulledBallot&gl_SubGroupLeMaskARB);
        if (gl_SubGroupInvocationID==0u)
           scratch[gl_SubgroupID] = bitcount(notCulledBallot);

        irr_glsl_workgroupScanAddExclusive_scratch(gl_WorkGroupSize/gl_SubGroupSize);
        return scratch[gl_SubgroupID]+localInclPrefix;
    */
	if (notCulled)
	    outputIndex = atomicAdd(visibleObjectCount,1u);

    if (lod<specConstantMaxLoDLevels)
    {
		mat3 normalMatrixT = mat3(pc.viewProjMatrixInverse)*mat3(obj.worldNormalMatrixRow0,obj.worldNormalMatrixRow0,obj.worldNormalMatrixRow0);


		VisibleObject_t objectToDraw;

		objectToDraw.modelViewProjectionMatrix = modelViewProjectionMatrix;
		objectToDraw.normalMatrixRow0 = normalMatrixT[0];
		objectToDraw.cameraID = 0u;
		objectToDraw.normalMatrixRow1 = normalMatrixT[1];
		objectToDraw.objectUUID = objectUUID;
		objectToDraw.normalMatrixRow2 = normalMatrixT[2];
		objectToDraw.meshUUID = models[modelUUID].LoDDMeshUUID[lod];

		visibleObjects[outputIndex] = objectToDraw;
	}
}
