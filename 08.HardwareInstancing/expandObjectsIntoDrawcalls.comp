#version 430 core

#include "shaderCommon.glsl"

layout(local_size_x = kOptimalWorkgroupSize) in;


layout(set = 0, binding = 0, std430) restrict readonly buffer Models
{
    ModelData_t models[];
};
layout(set = 0, binding = 1, std430, row_major) restrict readonly buffer Objects
{
    SceneNode_t objects[];
};

layout(set = 1, binding = 0, std430) restrict coherent buffer VisibleObjectCounter
{
    uint visibleObjectCount;
};
layout(set = 1, binding = 1, std430, row_major) restrict writeonly buffer VisibleObjects
{
    VisibleObject_t visibleObjects[];
};

layout(set = 2, binding = 0, std430, row_major) uniform Cameras
{
    // NOTE: could be an array of `Camera_t` and we could use `gl_GlobalInvocationID.y` to index cameras (or subdivide the X dimension of a workgroup)
    mat4 viewProjMatrix;
    mat4 viewProjMatrixInverse;
    vec3 cameraPosition;
} camera;

layout(set = 2, binding = 1, std430) restrict writeonly buffer InstanceRedirectKeys
{
    uint instanceRedirectKeys[];
};
layout(set = 2, binding = 2, std430) restrict writeonly buffer InstanceRedirect
{
    uint objectUUIDRedirects[];
};


layout(push_constant) uniform PushConstants
{
    uint objectCount;
} pc;


void main()
{
// this is all fucked

    // increment instance counter for the correct drawID
        const uint baseInstance = .draws[meshBufferUUID].baseInstance;
        const uint instanceID = atomicAdd(.draws[meshBufferUUID].instanceCount,1u)+baseInstance;
    // output tuple of <drawID,instanceID (result of previous atomicAdd),objectID>
        instanceRedirectKeys[baseInstance]
}
