#version 430 core

#include "shaderCommon.glsl"

layout(local_size_x = kOptimalWorkgroupSize) in;


layout(set = 0, binding = 0, std430) restrict readonly buffer Models
{
    ModelData_t models[];
};
layout(set = 0, binding = 1, std430, row_major) restrict readonly buffer Objects
{
    SceneNode_t objects[];
};

layout(set = 1, binding = 0, std430) restrict readonly buffer VisibleObjectCounter
{
    uint visibleObjectCount;
};
layout(set = 1, binding = 1, std430, row_major) restrict readonly buffer VisibleObjects
{
    VisibleObject_t visibleObjects[];
};


void main()
{
    const bool canProcessObj = gl_GlobalInvocationID.x>=visibleObjectCount;
    if (canProcessObj)
    {
        VisibleObject_t visObj = visibleObjects[gl_GlobalInvocationID.x];

        for (uint i=0u; i<mesh.meshBufferCount; i++)
        {
        }
    }

    // increment instance counter for the correct drawID
        const uint baseInstance = .draws[meshBufferUUID].baseInstance;
        const uint instanceID = atomicAdd(.draws[meshBufferUUID].instanceCount,1u)+baseInstance;
    // output tuple of <drawID,instanceID (result of previous atomicAdd),objectID>
        instanceRedirectKeys[baseInstance]
}
