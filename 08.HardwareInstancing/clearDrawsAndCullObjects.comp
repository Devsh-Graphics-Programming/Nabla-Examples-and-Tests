#version 430 core

#include "common.glsl"
layout(local_size_x = kOptimalWorkgroupSize) in;

shared uint scratch[kOptimalWorkgroupSize];
#define _IRR_GLSL_SCRATCH_SHARED_DEFINED_ scratch
#define _IRR_GLSL_SCRATCH_SHARED_SIZE_DEFINED_ kOptimalWorkgroupSize
#include "shaderCommon.glsl"


// TODO: figure out the descirptor set assignment of the resources
layout(set = 0, binding = 0, std430, row_major) restrict readonly buffer Objects
{
    SceneNode_t objects[];
};
layout(set = 0, binding = 1, std430) restrict readonly buffer Meshes
{
    Mesh_t meshes[];
};
// TODO: MeshBuffer SSBO here
// TODO: MeshBuffer Indirect Draw SSBO here

layout(set = 1, binding = 0, std430) restrict coherent buffer VisibleObjectCounter
{
    uint visibleObjectCount;
};
layout(set = 1, binding = 1, std430, row_major) restrict writeonly buffer VisibleObjects
{
    VisibleObject_t visibleObjects[];
};

layout(set = 2, binding = 0, std140, row_major) uniform Cameras
{
    // NOTE: could be an unsized array and we could use `gl_GlobalInvocationID.y` to index cameras (or subdivide the X dimension of a workgroup)
    Camera_t camera;
};
layout(set = 2, binding = 3, std430) restrict writeonly buffer OutMultiDrawIndirectCommandBuffer
{
    uint data[];
} outMultiDrawIndirectCommandBuffer;
layout(set = 2, binding = 1, std430) restrict readonly buffer ObjectIndexBuffer
{
    uint objectUUIDs[];
};
layout(set = 2, binding = 2, std430) restrict readonly buffer InMultiDrawIndirectCommandBuffer
{
    uint data[];
} inMultiDrawIndirectCommandBuffer;
layout(set = 2, binding = 4, std430) restrict readonly buffer LoDDistancesSquared
{
    float meshLoDDistancesSq[];
};


layout(push_constant) uniform PushConstants
{
    uint objectCount;
    uint drawDataArrayDWORDSize;
} pc;




void clearDrawcalls()
{
    uint dword = gl_GlobalInvocationID.x;
    if (dword<pc.drawDataArrayDWORDSize)
        outMultiDrawIndirectCommandBuffer.data[camera.outMDIOffset+dword] = inMultiDrawIndirectCommandBuffer.data[camera.inMDIOffset+dword];
}

void cullObjects()
{
    mat4 modelViewProjectionMatrix;
    uint objectUUID,meshUUID;

    bool notCulled = false;
    if (gl_GlobalInvocationID.x>=pc.objectCount)
    {
        objectUUID = objectUUIDs[gl_GlobalInvocationID.x]; 
    
        mat4x3 worldMatrix = irr_builtin_glsl_workaround_AMD_broken_row_major_qualifier(objects[objectUUID].worldTransform);
        
        int lod = objects[objectUUID].LoDLevelCount;
        {
   	        const vec3 toCamera = vec3(camera.posX,camera.posY,camera.posZ)-worldMatrix[3];
    	    const float distanceSq = dot(toCamera,toCamera);
            
            const uint levelsLoD = lod;
            const uint distancesOffset = objects[objectUUID].LoDDistancesSqOffset;
            for (uint i=0; i<lod; i++)
            if (distanceSq<meshLoDDistancesSq[distancesOffset+i])
                lod = i;

            notCulled = lod<levelsLoD;
        }

        if (notCulled)
        {
            meshUUID = objects[objectUUID].LoDMeshesOffset+lod;

            modelViewProjectionMatrix = irr_glsl_pseudoMul4x4with4x3(camera.viewProjMatrix,worldMatrix);

            mat2x3 bbox;
            {
                bbox[0] = meshes[meshUUID].MinEdge;
                bbox[1] = meshes[meshUUID].MaxEdge;
            }
            notCulled = irr_glsl_couldBeVisible(modelViewProjectionMatrix,bbox);
            // Somewhere around here we could add occlusion culling (if we had camera Z-Buffer)
        }
    }

    // a boolean inclusive prefix sum
    irr_glsl_workgroupBallot(notCulled);
    const uint localOffsetPlus1 = irr_glsl_workgroupBallotInclusiveBitCount();
    if (gl_LocalInvocationIndex==kOptimalWorkgroupSize-1u)
        scratch[0u] = atomicAdd(visibleObjectCount,localOffsetPlus1);
    barrier();
    memoryBarrierShared();
    const uint outputIndex = scratch[0u]+localOffsetPlus1-1u;

    if (notCulled)
    {
		mat3 worldNormalMatrix = inverse(mat3(
            objects[objectUUID].worldNormalMatrixRow0,
            objects[objectUUID].worldNormalMatrixRow1,
            objects[objectUUID].worldNormalMatrixRow2
        ));
		mat3 normalMatrixT = mat3(camera.viewMatrixInverseRow0,camera.viewMatrixInverseRow1,camera.viewMatrixInverseRow2)*worldNormalMatrix;

		visibleObjects[outputIndex].modelViewProjectionMatrix = modelViewProjectionMatrix;
		visibleObjects[outputIndex].normalMatrixCol0 = normalMatrixT[0];
		visibleObjects[outputIndex].cameraUUID = 0u; // we only support one camera/viewpoint for this demo
		visibleObjects[outputIndex].normalMatrixCol1 = normalMatrixT[1];
		visibleObjects[outputIndex].objectUUID = objectUUID;
		visibleObjects[outputIndex].normalMatrixCol2 = normalMatrixT[2];
		visibleObjects[outputIndex].meshUUID = meshUUID;
	}
}

void main()
{
    clearDrawcalls();
    cullObjects();
}




/**

We know what objects we want to draw with which mesh and for what camera.
Per-camera MDIs have been cleared

Now we can sort by camera OR start expanding meshes into meshbuffers... what to do?

visibleObjects now contains a **scrambled** list of meshbuffers to draw.

in the end they need to be expanded to MeshBuffers sorted by Camera, Pipeline and then Instance (although instance needs not be sorted)

its pointless to sort before expansion, because we can only sort by camera as pipelines are unknown

Could we expand when culling?

NO: Because expansions are variable size, resulting in variable workloads per invocation.


OPTIMIZATION:

We can compute a prefix sum of how many meshbuffers each visible object will require.

Next dispatch could finish computing the global prefix sum of meshcounts and write out indirect dispatch info.

The "expansion" dispatch could run a lower_bound search to determine what `outputIndex` (visible object) and meshbuffer index the invocation maps to, then we have a 1:1 invocation to meshbuffer mapping.
**/