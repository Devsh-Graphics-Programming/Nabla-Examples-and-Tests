#version 450 core

layout(local_size_x=840) in;

#define LOD_COUNT 10

// Todo(achal): I should probably make it a push constant??
#define CLIPMAP_EXTENT 11977.0674f
#define VOXEL_COUNT_PER_DIM 4
#define VOXEL_COUNT_PER_LEVEL 64

#define LIGHT_CONTRIBUTION_THRESHOLD 2.f
#define LIGHT_RADIUS 25.f

struct nbl_glsl_ext_ClusteredLighting_SpotLight
{
	vec3 position;
	float outerCosineOverCosineRange;
	uvec2 intensity;
	uvec2 direction;
};

struct cone_t
{
	vec3 tip;
	float height;
	vec3 direction;
	float cosHalfAngle;
	float baseRadius;
};

layout (push_constant) uniform Block
{
	vec4 camPosClipmapExtent;
} pushConstants;

#include <nbl/builtin/glsl/shapes/aabb.glsl>

layout (set = 0, binding = 0, std430) restrict buffer readonly Lights
{
	nbl_glsl_ext_ClusteredLighting_SpotLight data[];
} lights;

layout (set = 0, binding = 1, std430) restrict buffer readonly ActiveLightIndices
{
	uint data[];
} activeLightIndices;

layout (set = 0, binding = 2, std430) restrict buffer writeonly IntersectionRecords
{
	uvec2 data[];
} intersectionRecords;

layout (set = 0, binding = 3) buffer IntersectionRecordCount
{
	uvec3 data;
} intersectionRecordCount;

layout (set = 0, binding = 4, r32ui) restrict uniform uimage3D lightGrid;

layout (set = 0, binding = 5, std430) restrict buffer ScratchBuffer
{
	uint data[];
} scratchBuffer;

#include <nbl/builtin/glsl/format/decode.glsl>

bool isPointBehindPlane(in vec3 point, in vec4 plane)
{
	// As an optimization we can add an epsilon to 0, to ignore cones which have a
	// very very small intersecting region with the AABB, could help with FP precision
	// too when the point is on the plane
	return (dot(point, plane.xyz) + plane.w) <= 0.f /* + EPSILON*/;
}

cone_t getLightVolume(in nbl_glsl_ext_ClusteredLighting_SpotLight light)
{
	cone_t cone;

	// tip
	cone.tip = light.position;

	// height
	const float radiusSq = LIGHT_RADIUS * LIGHT_RADIUS;

	const vec3 intensity = nbl_glsl_decodeRGB19E7(light.intensity);
	const float maxIntensityComponent = max(max(intensity.r, intensity.g), intensity.b);
	const float determinant = clamp(1.f - ((2.f * LIGHT_CONTRIBUTION_THRESHOLD) / (maxIntensityComponent * radiusSq)), -1.f, 1.f);

	cone.height = LIGHT_RADIUS * inversesqrt(1.f / (determinant * determinant) - 1.f);

	// direction
	const vec2 dirXY = unpackSnorm2x16(light.direction[0]);
	const vec2 dirZW = unpackSnorm2x16(light.direction[1]);
	cone.direction = vec3(dirXY.xy, dirZW.x);

	// cosHalfAngle
	// Todo(achal): I cannot handle spotlights/cone intersection against AABB
	// if it has outerHalfAngle > 90.f, hence the `max`
	const float cosineRange = dirZW.y;
	cone.cosHalfAngle = max(light.outerCosineOverCosineRange * cosineRange, 1e-3f);

	// baseRadius
	const float tanOuterHalfAngle = sqrt(max(1.f - (cone.cosHalfAngle * cone.cosHalfAngle), 0.f)) / cone.cosHalfAngle;
	cone.baseRadius = cone.height * tanOuterHalfAngle;

	return cone;
}

// Todo(achal): Rename to getClusterAABB
nbl_glsl_shapes_AABB_t getCluster(in uvec3 localClusterID, in vec3 levelMinVertex, in float voxelSideLength)
{
	const vec3 camPos = pushConstants.camPosClipmapExtent.xyz;

	nbl_glsl_shapes_AABB_t cluster;
	cluster.minVx = levelMinVertex + (localClusterID * voxelSideLength) + camPos;
	cluster.maxVx = levelMinVertex + (localClusterID + uvec3(1u))*voxelSideLength + camPos;
	return cluster;
}

#define PLANE_COUNT 6
vec4[PLANE_COUNT] getAABBPlanes(in nbl_glsl_shapes_AABB_t aabb)
{
	vec4 planes[PLANE_COUNT];

	// 157
	vec3 p0 = vec3(aabb.maxVx.x, aabb.minVx.y, aabb.minVx.z);
	vec3 p1 = vec3(aabb.maxVx.x, aabb.minVx.y, aabb.maxVx.z);
	vec3 p2 = vec3(aabb.maxVx.x, aabb.maxVx.y, aabb.maxVx.z);
	planes[0].xyz = normalize(cross(p1-p0, p2-p0));
	planes[0].w = -dot(planes[0].xyz, p0);

	// 013
	p0 = vec3(aabb.minVx.x, aabb.minVx.y, aabb.minVx.z);
	p1 = vec3(aabb.maxVx.x, aabb.minVx.y, aabb.minVx.z);
	p2 = vec3(aabb.maxVx.x, aabb.maxVx.y, aabb.minVx.z);
	planes[1].xyz = normalize(cross(p1-p0, p2-p0));
	planes[1].w = -dot(planes[1].xyz, p0);

	// 402
	p0 = vec3(aabb.minVx.x, aabb.minVx.y, aabb.maxVx.z);
	p1 = vec3(aabb.minVx.x, aabb.minVx.y, aabb.minVx.z);
	p2 = vec3(aabb.minVx.x, aabb.maxVx.y, aabb.minVx.z);
	planes[2].xyz = normalize(cross(p1-p0, p2-p0));
	planes[2].w = -dot(planes[2].xyz, p0);

	// 546
	p0 = vec3(aabb.maxVx.x, aabb.minVx.y, aabb.maxVx.z);
	p1 = vec3(aabb.minVx.x, aabb.minVx.y, aabb.maxVx.z);
	p2 = vec3(aabb.minVx.x, aabb.maxVx.y, aabb.maxVx.z);
	planes[3].xyz = normalize(cross(p1-p0, p2-p0));
	planes[3].w = -dot(planes[3].xyz, p0);

	// 451
	p0 = vec3(aabb.minVx.x, aabb.minVx.y, aabb.maxVx.z);
	p1 = vec3(aabb.maxVx.x, aabb.minVx.y, aabb.maxVx.z);
	p2 = vec3(aabb.maxVx.x, aabb.minVx.y, aabb.minVx.z);
	planes[4].xyz = normalize(cross(p1-p0, p2-p0));
	planes[4].w = -dot(planes[4].xyz, p0);

	// 762
	p0 = vec3(aabb.maxVx.x, aabb.maxVx.y, aabb.maxVx.z);
	p1 = vec3(aabb.minVx.x, aabb.maxVx.y, aabb.maxVx.z);
	p2 = vec3(aabb.minVx.x, aabb.maxVx.y, aabb.minVx.z);
	planes[5].xyz = normalize(cross(p1-p0, p2-p0));
	planes[5].w = -dot(planes[5].xyz, p0);

	return planes;
}

bool coneIntersectAABB(in cone_t cone, in nbl_glsl_shapes_AABB_t aabb)
{
	vec4 planes[PLANE_COUNT] = getAABBPlanes(aabb);

	for (uint i = 0u; i < PLANE_COUNT; ++i)
	{
		const vec3 m = cross(cross(planes[i].xyz, cone.direction), cone.direction);
		const vec3 farthestBasePoint = cone.tip + (cone.direction * cone.height) - (m * cone.baseRadius); // farthest to plane's surface, away from positive half-space

		// There are two edge cases here:
		// 1. When cone's direction and plane's normal are anti-parallel
		//		There is no reason to check farthestBasePoint in this case, because cone's tip is the farthest point!
		//		But there is no harm in doing so.
		// 2. When cone's direction and plane's normal are parallel
		//		This edge case will get handled nicely by the farthestBasePoint coming as center of the base of the cone itself
		if (isPointBehindPlane(cone.tip, planes[i]) && isPointBehindPlane(farthestBasePoint, planes[i]))
			return false;
	}

	return true;
}

struct intersection_record_t
{
	uvec3 localClusterID; // 7 bits per dim
	uint level; // 4 bits
	uint localLightIndex; // 12 bits, Todo(achal): Make this 10
	uint globalLightIndex; // 20 bits, Todo(achal): Make this 22
};

uvec2 packIntersectionRecord(in intersection_record_t record)
{
	uvec2 result = uvec2(0u);
	result.x |= record.localClusterID.x;
	result.x |= (record.localClusterID.y << 7);
	result.x |= (record.localClusterID.z << 14);
	result.x |= (record.level << 21);

	result.y |= record.localLightIndex;
	result.y |= (record.globalLightIndex << 12); // Todo(achal): Make this 10

	return result;
}

#define INVALID_INDEX ~0u

void main()
{
	if (gl_GlobalInvocationID.x == 0)
		atomicExchange(intersectionRecordCount.data.x, 0u);

	scratchBuffer.data[gl_GlobalInvocationID.x] = INVALID_INDEX; // visibility for this would work without any barrier

	const vec3 camPos = pushConstants.camPosClipmapExtent.xyz;
	const float clipmapExtent = pushConstants.camPosClipmapExtent.w;

	// Todo(achal): Should just be #define
	const uint clustersPerLevel = 64u;

	for (int level = LOD_COUNT-1; level >= 0; --level)
	{
		const uint globalLightIndex = (level==LOD_COUNT-1) ? activeLightIndices.data[gl_GlobalInvocationID.x] : scratchBuffer.data[gl_GlobalInvocationID.x];
		if (globalLightIndex == INVALID_INDEX)
			continue; // Todo(achal): `discard`???

		const nbl_glsl_ext_ClusteredLighting_SpotLight light = lights.data[globalLightIndex];
		const cone_t cone = getLightVolume(light);

		const float levelExtent = clipmapExtent / (1 << (LOD_COUNT - 1 - level));
		const vec3 levelMinVertex = vec3(-levelExtent/2.f);
		const float voxelSideLength = levelExtent / VOXEL_COUNT_PER_DIM;

		// traverse the outer nodes first
		for (uint clusterZ = 0u; clusterZ < VOXEL_COUNT_PER_DIM; ++clusterZ)
		{
			for (uint clusterY = 0u; clusterY < VOXEL_COUNT_PER_DIM; ++clusterY)
			{
				for (uint clusterX = 0u; clusterX < VOXEL_COUNT_PER_DIM; ++clusterX)
				{
					const uvec3 localClusterID = uvec3(clusterX, clusterY, clusterZ);

					// Todo(achal): Could probably use some glsl stuff here like any/all/lessThan whatever..
					const bool isMidRegion =
						(localClusterID.x >= 1 && localClusterID.x <= 2) &&
						(localClusterID.y >= 1 && localClusterID.y <= 2) &&
						(localClusterID.z >= 1 && localClusterID.z <= 2);

					if (!isMidRegion)
					{
						const nbl_glsl_shapes_AABB_t cluster = getCluster(localClusterID, levelMinVertex, voxelSideLength);				
						if (coneIntersectAABB(cone, cluster))
						{
							// Record intersection
							intersection_record_t record;
							record.localClusterID = localClusterID;
							record.level = level;

							// Todo(achal): VOXEL_COUNT_PER_LEVEL
							const uint globalClusterIndex = (LOD_COUNT-1-level)*64 + localClusterID.z*16 + localClusterID.y*4 + localClusterID.x;
							ivec3 lightGridTexCoords;
							{
								const uint voxelCountX = VOXEL_COUNT_PER_DIM;
								const uint voxelCountY = VOXEL_COUNT_PER_DIM;
								const uint voxelCountPerSlice = voxelCountX*voxelCountY;
								lightGridTexCoords.z = int(globalClusterIndex/voxelCountPerSlice);
								const int xy = int(globalClusterIndex%voxelCountPerSlice);
								lightGridTexCoords.y = int(xy/voxelCountX);
								lightGridTexCoords.x = int(xy%voxelCountX);
							}
							record.localLightIndex = imageAtomicAdd(lightGrid, lightGridTexCoords, 1u);

							record.globalLightIndex = globalLightIndex;
							const uvec2 packed = packIntersectionRecord(record);
							intersectionRecords.data[atomicAdd(intersectionRecordCount.data.x, 1u)] = packed;

							// "Erase" this globalLightIndex from scratchBuffer
							scratchBuffer.data[gl_GlobalInvocationID.x] = INVALID_INDEX;
						}
					}
				}
			}
		}

		// now traverse the inner nodes
		// Todo(achal): Not hardcode, write in terms of VOXEL_COUNT_PER_DIM
		for (uint clusterZ = 1u; clusterZ <= 2u; ++clusterZ)
		{
			for (uint clusterY = 1u; clusterY <= 2u; ++clusterY)
			{
				for (uint clusterX = 1u; clusterX <= 2u; ++clusterX)
				{
					const uvec3 localClusterID = uvec3(clusterX, clusterY, clusterZ);
					const nbl_glsl_shapes_AABB_t cluster = getCluster(localClusterID, levelMinVertex, voxelSideLength);
					if (coneIntersectAABB(cone, cluster))
					{
						if (level == 0u)
						{
							// Record intersection
							intersection_record_t record;
							record.localClusterID = localClusterID;
							record.level = level;

							// Todo(achal): Need to pull this out into getGlobalClusterIndex or something
							const uint globalClusterIndex = (LOD_COUNT-1-level)*64 + localClusterID.z*16 + localClusterID.y*4 + localClusterID.x;
							// get 3D light grid coords
							ivec3 lightGridTexCoords;
							{
								const uint voxelCountX = VOXEL_COUNT_PER_DIM;
								const uint voxelCountY = VOXEL_COUNT_PER_DIM;
								const uint voxelCountPerSlice = voxelCountX*voxelCountY;
								lightGridTexCoords.z = int(globalClusterIndex/voxelCountPerSlice);
								const int xy = int(globalClusterIndex%voxelCountPerSlice);
								lightGridTexCoords.y = int(xy/voxelCountX);
								lightGridTexCoords.x = int(xy%voxelCountX);
							}

							record.localLightIndex = imageAtomicAdd(lightGrid, lightGridTexCoords, 1u);

							record.globalLightIndex = globalLightIndex;
							const uvec2 packed = packIntersectionRecord(record);
							intersectionRecords.data[atomicAdd(intersectionRecordCount.data.x, 1u)] = packed;

							// "Erase" this globalLightIndex from scratchBuffer
							scratchBuffer.data[gl_GlobalInvocationID.x] = INVALID_INDEX;
						}	
						else
						{
							scratchBuffer.data[gl_GlobalInvocationID.x] = globalLightIndex;
						}
					}
				}
			}
		}
	}
}