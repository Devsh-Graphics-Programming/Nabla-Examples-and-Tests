#version 450 core

layout (push_constant) uniform Block
{
	vec4 camPosClipmapExtent;
	uint hierarchyLevel;
} pc;

#include <../cull_common.glsl>

layout (set = 0, binding = 0, std430) restrict buffer readonly Lights
{
	nbl_glsl_ext_ClusteredLighting_SpotLight data[];
} lights;

layout (set = 0, binding = 1, std430) restrict buffer readonly InScratch
{
	uint count;
	uint data[];
} inScratch;

layout (set = 0, binding = 2, std430) restrict buffer writeonly OutScratch
{
	uint count;
	uint data[];
} outScratch;

layout (set = 0, binding = 3, std430) restrict buffer writeonly IntersectionRecords
{
	uint count;
	uint padding;
	uvec2 data[];
} intersectionRecords;

layout (set = 0, binding = 4, r32ui) restrict uniform uimage3D lightGrid;

// Todo(achal): Make this come in via host, make it 7
#define LOD_COUNT 10
// Todo(achal): Make this come in via host
#define VOXEL_COUNT_PER_DIM 4

#define INVALID_INDEX ~0u

void main()
{
	if ((gl_GlobalInvocationID.x >= LIGHT_COUNT )|| (inScratch.data[gl_GlobalInvocationID.x] == INVALID_INDEX))
		return;

	const uint globalLightIndex = inScratch.data[gl_GlobalInvocationID.x];
	const nbl_glsl_ext_ClusteredLighting_SpotLight light = lights.data[globalLightIndex];
	const cone_t cone = getLightVolume(light);

	const float clipmapExtent = pc.camPosClipmapExtent.w;
	const float levelExtent = clipmapExtent / (1 << (LOD_COUNT - 1 - pc.hierarchyLevel));
	const vec3 levelMinVertex = vec3(-levelExtent/2.f);
	const float voxelSideLength = levelExtent / VOXEL_COUNT_PER_DIM;

	// it is important to traverse the outer nodes first
	for (uint clusterZ = 0u; clusterZ < VOXEL_COUNT_PER_DIM; ++clusterZ)
	{
		for (uint clusterY = 0u; clusterY < VOXEL_COUNT_PER_DIM; ++clusterY)
		{
			for (uint clusterX = 0u; clusterX < VOXEL_COUNT_PER_DIM; ++clusterX)
			{
				const uvec3 localClusterID = uvec3(clusterX, clusterY, clusterZ);

				// Todo(achal): Could probably use some glsl stuff here like any/all/lessThan whatever..
				const bool isMidRegion =
						(localClusterID.x >= 1 && localClusterID.x <= 2) &&
						(localClusterID.y >= 1 && localClusterID.y <= 2) &&
						(localClusterID.z >= 1 && localClusterID.z <= 2);

				if (!isMidRegion)
				{
					const nbl_glsl_shapes_AABB_t cluster = getCluster(localClusterID, levelMinVertex, voxelSideLength);
					if (coneIntersectAABB(cone, cluster))
					{
						// Record intersection
						intersection_record_t record;
						record.localClusterID = localClusterID;
						record.level = pc.hierarchyLevel; // Todo(achal): Do we need this anymore?

						// Todo(achal): VOXEL_COUNT_PER_LEVEL
						const uint globalClusterIndex = (LOD_COUNT-1-pc.hierarchyLevel)*64 + localClusterID.z*16 + localClusterID.y*4 + localClusterID.x;
						// Todo(achal): Use the function here
						ivec3 lightGridTexCoords;
						{
							const uint voxelCountX = VOXEL_COUNT_PER_DIM;
							const uint voxelCountY = VOXEL_COUNT_PER_DIM;
							const uint voxelCountPerSlice = voxelCountX*voxelCountY;
							lightGridTexCoords.z = int(globalClusterIndex/voxelCountPerSlice);
							const int xy = int(globalClusterIndex%voxelCountPerSlice);
							lightGridTexCoords.y = int(xy/voxelCountX);
							lightGridTexCoords.x = int(xy%voxelCountX);
						}
						record.localLightIndex = imageAtomicAdd(lightGrid, lightGridTexCoords, 1u);
						record.globalLightIndex = globalLightIndex;

						const uvec2 packed = packIntersectionRecord(record);
						intersectionRecords.data[atomicAdd(intersectionRecords.count, 1u)] = packed;

						// "Erase" this globalLightIndex from scratchBuffer
						outScratch.data[gl_GlobalInvocationID.x] = INVALID_INDEX;
					}
				}

			}
		}
	}
	memoryBarrier();

	// now traverse the inner nodes
	// Todo(achal): Not hardcode, write in terms of VOXEL_COUNT_PER_DIM
	for (uint clusterZ = 1u; clusterZ <= 2u; ++clusterZ)
	{
		for (uint clusterY = 1u; clusterY <= 2u; ++clusterY)
		{
			for (uint clusterX = 1u; clusterX <= 2u; ++clusterX)
			{
				const uvec3 localClusterID = uvec3(clusterX, clusterY, clusterZ);
				const nbl_glsl_shapes_AABB_t cluster = getCluster(localClusterID, levelMinVertex, voxelSideLength);
				if (coneIntersectAABB(cone, cluster))
				{
					if (pc.hierarchyLevel == 0u)
					{
						// Record intersection
						intersection_record_t record;
						record.localClusterID = localClusterID;
						record.level = pc.hierarchyLevel;

						// Todo(achal): VOXEL_COUNT_PER_LEVEL
						const uint globalClusterIndex = (LOD_COUNT-1-pc.hierarchyLevel)*64 + localClusterID.z*16 + localClusterID.y*4 + localClusterID.x;
						// Todo(achal): Use the function here
						ivec3 lightGridTexCoords;
						{
							const uint voxelCountX = VOXEL_COUNT_PER_DIM;
							const uint voxelCountY = VOXEL_COUNT_PER_DIM;
							const uint voxelCountPerSlice = voxelCountX*voxelCountY;
							lightGridTexCoords.z = int(globalClusterIndex/voxelCountPerSlice);
							const int xy = int(globalClusterIndex%voxelCountPerSlice);
							lightGridTexCoords.y = int(xy/voxelCountX);
							lightGridTexCoords.x = int(xy%voxelCountX);
						}
						record.localLightIndex = imageAtomicAdd(lightGrid, lightGridTexCoords, 1u);
						record.globalLightIndex = globalLightIndex;

						const uvec2 packed = packIntersectionRecord(record);
						intersectionRecords.data[atomicAdd(intersectionRecords.count, 1u)] = packed;
					}
					else
					{
						outScratch.data[gl_GlobalInvocationID.x] = globalLightIndex;
					}
				}
			}
		}
	}

}