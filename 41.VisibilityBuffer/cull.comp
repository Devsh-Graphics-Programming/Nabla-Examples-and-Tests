#version 430 core

#include "rasterizationCommon.h"
layout(local_size_x = WORKGROUP_SIZE) in;

layout(set=0, binding=0, std430, row_major) restrict readonly buffer PerInstanceCull
{
    CullData_t cullData[];
};
layout(set=0, binding=1, std430) restrict coherent buffer MVPs
{
    mat4 mvps[];
} mvpBuff;

#define ENABLE_CUBE_COMMAND_BUFFER
#define ENABLE_FRUSTUM_CULLED_COMMAND_BUFFER
#define ENABLE_OCCLUSION_CULLED_COMMAND_BUFFER
#define ENABLE_CUBE_DRAW_GUID_BUFFER
#define CUBE_COMMAND_BUFF_SET 0
#define CUBE_COMMAND_BUFF_BINDING 2
#define FRUSTUM_CULLED_COMMAND_BUFF_SET 0
#define FRUSTUM_CULLED_COMMAND_BUFF_BINDING 3
#define OCCLUSION_CULLED_COMMAND_BUFF_SET 0
#define OCCLUSION_CULLED_COMMAND_BUFF_BINDING 4
#define CUBE_DRAW_GUID_BUFF_SET 0
#define CUBE_DRAW_GUID_BUFF_BINDING 5
#include "occlusionCullingShaderCommon.glsl"

layout(set=0, binding=6, std430) restrict buffer CubeMVPs
{
    mat4 cubeMVPs[];
} cubeMvpBuff;


layout(push_constant, row_major) uniform PushConstants
{
    CullShaderData_t data;
} pc;



#include <nbl/builtin/glsl/utils/culling.glsl>
#include <nbl/builtin/glsl/utils/transform.glsl>


void main()
{
    if (gl_GlobalInvocationID.x >= pc.data.maxBatchCount)
        return;

    mvpBuff.mvps[gl_GlobalInvocationID.x] = pc.data.viewProjMatrix; // no model matrices

    if (bool(pc.data.freezeCulling))
        return;

    const CullData_t batchCullData = cullData[gl_GlobalInvocationID.x];

    const mat2x3 bbox = mat2x3(batchCullData.aabbMinEdge,batchCullData.aabbMaxEdge);
    bool couldBeVisible = nbl_glsl_couldBeVisible(pc.data.viewProjMatrix,bbox);
    
    const uint drawCommandGUID = batchCullData.drawCommandGUID;

    if(!couldBeVisible)
        frustumCommandBuff.draws[drawCommandGUID].instanceCount = 0;

    // if not frustum culled and batch was not visible in the last frame
    if(couldBeVisible && frustumCommandBuff.draws[drawCommandGUID].instanceCount == 0)
    {
        const uint currCubeIdx = atomicAdd(cubeIndirectDraw.draw.instanceCount,1);

        vec3 aabbExtent = batchCullData.aabbMaxEdge - batchCullData.aabbMinEdge;
        cubeMvpBuff.cubeMVPs[currCubeIdx] = mat4(
            pc.data.viewProjMatrix[0]*aabbExtent.x,
            pc.data.viewProjMatrix[1]*aabbExtent.y,
            pc.data.viewProjMatrix[2]*aabbExtent.z,
            vec4(mat3(pc.data.viewProjMatrix)*batchCullData.aabbMinEdge,1)+pc.data.viewProjMatrix[3]
        );

        cubeDrawGUIDBuffer.drawGUID[currCubeIdx] = drawCommandGUID;
    }

    occlusionCommandBuff.draws[drawCommandGUID].instanceCount = 0;

}