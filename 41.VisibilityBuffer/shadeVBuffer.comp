#version 430 core

#include "common.glsl"
layout (local_size_x = 16, local_size_y = 16) in;

#include <nbl/builtin/glsl/virtual_texturing/extensions.glsl>
#include <nbl/builtin/glsl/virtual_texturing/descriptors.glsl>
layout (set = 2, binding = 3, std430) restrict readonly buffer PrecomputedStuffSSBO
{
    uint pgtab_sz_log2;
    float vtex_sz_rcp;
    float phys_pg_tex_sz_rcp[_NBL_VT_MAX_PAGE_TABLE_LAYERS];
    uint layer_to_sampler_ix[_NBL_VT_MAX_PAGE_TABLE_LAYERS];
} precomputed;

layout(set = 3, binding = 0) uniform sampler2D vBuffer;
layout(set = 3, binding = 1, r32ui) uniform uimage2D frameBuffer;

#include <nbl/builtin/glsl/loader/mtl/common.glsl>
BatchInstanceData gBatchInstance;
nbl_glsl_MTLMaterialParameters nbl_glsl_getMaterialParameters() // this function is for MTL's shader only
{
    nbl_glsl_MTLMaterialParameters mtl_params;
    mtl_params.Ka = gBatchInstance.Ka;
    mtl_params.Kd = gBatchInstance.Kd;
    mtl_params.Ks = gBatchInstance.Ks;
    mtl_params.Ke = gBatchInstance.Ke;
    mtl_params.Ns = gBatchInstance.Ns;
    mtl_params.d = gBatchInstance.d;
    mtl_params.Ni = gBatchInstance.Ni;
    mtl_params.extra = gBatchInstance.extra;
    return mtl_params;
}
#define _NBL_FRAG_GET_MATERIAL_PARAMETERS_FUNCTION_DEFINED_


uint nbl_glsl_VT_layer2pid(in uint layer)
{
    return precomputed.layer_to_sampler_ix[layer];
}
uint nbl_glsl_VT_getPgTabSzLog2()
{
    return precomputed.pgtab_sz_log2;
}
float nbl_glsl_VT_getPhysPgTexSzRcp(in uint layer)
{
    return precomputed.phys_pg_tex_sz_rcp[layer];
}
float nbl_glsl_VT_getVTexSzRcp()
{
    return precomputed.vtex_sz_rcp;
}
#define _NBL_USER_PROVIDED_VIRTUAL_TEXTURING_FUNCTIONS_


vec4 nbl_glsl_vTextureGrad


vec4 nbl_sample_Ka(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Ka_data, uv, dUV); }

vec4 nbl_sample_Kd(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Kd_data, uv, dUV); }

vec4 nbl_sample_Ks(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Ks_data, uv, dUV); }

vec4 nbl_sample_Ns(in vec2 uv, in mat2 dUV)   { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_Ns_data, uv, dUV); }

vec4 nbl_sample_d(in vec2 uv, in mat2 dUV)    { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_d_data, uv, dUV); }

vec4 nbl_sample_bump(in vec2 uv, in mat2 dUV) { return nbl_glsl_vTextureGrad(materialData[drawGUID].map_bump_data, uv, dUV); }



mat2x3 dPdBary;
mat2x3 nbl_glsl_perturbNormal_dPdSomething()
{
    return dPdBary;
}
mat2 dUVdBary;
mat2 nbl_glsl_perturbNormal_dUVdSomething()
{
    return dUVdBary;
}
#define _NBL_BUILTIN_GLSL_BUMP_MAPPING_DERIVATIVES_DECLARED_

void main()
{
    // TODO: out of bounds check and return
    const ivec2 fragCoord = ivec2(gl_GlobalInvocationID);
    if (any(greaterThanEqual(fragCoord,textureSize(vBuffer,0))))
        return;

    const uvec4 triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2 = texelFetch(vBuffer,fragCoord,0);
    
    const uint drawGUID = bitfieldExtract(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[0],MAX_TRIANGLES_IN_BATCH,32-MAX_TRIANGLES_IN_BATCH);
    const uint triangleID = bitfieldExtract(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[0],0,MAX_TRIANGLES_IN_BATCH);
    const vec2 bary = unpackUnorm2x16(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[1]);
    const mat2 dBary = mat2(
        unpackHalf2x16(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[2]),
        unpackHalf2x16(triangleIDdrawID_unorm16Bary_dBarydScreenHalf2x2[3])
    );

    gBatchInstance = batchInstanceData[drawID];
    const uint indexOffset = triangleID*3u+batchInstanceData.baseVertex;
    const uint vertexIDs[3] = {indexBuffer[indexOffset+0u],indexBuffer[indexOffset+1u],indexBuffer[indexOffset+2u]};

    vec3 pos,normal;
    vec2 uv;
    mat2 dUVdScreen;
    {
        vec3 positions[3];
        vec2 uvs[3];
        // wrap this up into a template macro?
        for (int i=0; i<3; i++)
        {
            positions[i] = nbl_glsl_fetchVtxPos(vertexIDs[i],drawGUID);
            uvs[i] = nbl_glsl_fetchVtxUV(vertexIDs[i],drawGUID);
        }

        // maybe could wrap this up into a function
        dPdBary[0] = positions[1]-positions[0];
        dPdBary[1] = positions[2]-positions[0];
        pos = dPdBary*bary+positions[0]; // TODO: compute from depth buffer or from barycentric? [Need Vib benchmark]

        dUVdBary[0] = uvs[1]-uvs[0];
        dUVdBary[1] = uvs[2]-uvs[0];
        uv = dUVdBary*bary+uvs[0];

        dUVdScreen = nbl_glsl_applyChainRule2D(dUVdBary,dBary);

        const float lastBary = 1.f-bary.x-bary.y;


        normal = nbl_glsl_fetchVtxNormal(vertices[0],drawGUID)*bary.x;
        normal += nbl_glsl_fetchVtxNormal(vertices[1],drawGUID)*bary.y;
        normal += nbl_glsl_fetchVtxNormal(vertices[2],drawGUID)*lastBary;
    }

    vec4 color; // TODO: shading

    imageStore(frameBuffer,fragCoord,color);
}