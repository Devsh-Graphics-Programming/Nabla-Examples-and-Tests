#ifndef _NBL_GLSL_WORKGROUP_SIZE_
#define _NBL_GLSL_WORKGROUP_SIZE_ (1 << 8)
layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;
#endif

layout (set = 0, binding = 0, std430) buffer inout_buffer
{
	uint inout_values[];
};

layout(push_constant) uniform pushConstants
{
    layout (offset = 0) uint stride;
	layout (offset = 4) uint element_count_pass;
	layout (offset = 8) uint element_count_total;
	layout (offset = 12) uint scan_op;
	layout (offset = 16) uint identity;
} pc;

#define STRIDED_IDX(i) (((i) + 1)*pc.stride-1)

#include <nbl/builtin/glsl/workgroup/arithmetic.glsl>

uint ScanExclusive(in uint val)
{
	switch (pc.scan_op)
	{
		case (1 << 0):
			return nbl_glsl_workgroupExclusiveAnd(val);
		case (1 << 1):
			return nbl_glsl_workgroupExclusiveXor(val);
		case (1 << 2):
			return nbl_glsl_workgroupExclusiveOr(val);
		case (1 << 3):
			return nbl_glsl_workgroupExclusiveAdd(val);
		case (1 << 4):
			return nbl_glsl_workgroupExclusiveMul(val);
		case (1 << 5):
			return nbl_glsl_workgroupExclusiveMin(val);
		case (1 << 6):
			return nbl_glsl_workgroupExclusiveMax(val);			
	}
}

uint ScanInclusive(in uint val)
{
	switch (pc.scan_op)
	{
		case (1 << 0):
			return nbl_glsl_workgroupInclusiveAnd(val);
		case (1 << 1):
			return nbl_glsl_workgroupInclusiveXor(val);
		case (1 << 2):
			return nbl_glsl_workgroupInclusiveOr(val);
		case (1 << 3):
			return nbl_glsl_workgroupInclusiveAdd(val);
		case (1 << 4):
			return nbl_glsl_workgroupInclusiveMul(val);
		case (1 << 5):
			return nbl_glsl_workgroupInclusiveMin(val);
		case (1 << 6):
			return nbl_glsl_workgroupInclusiveMax(val);			
	}
}

void main()
{
	uint idx = STRIDED_IDX(gl_GlobalInvocationID.x);
	if (idx >= pc.element_count_total)
		idx = pc.element_count_total - 1u;
	
	uint data = pc.identity;
	if (gl_GlobalInvocationID.x < pc.element_count_pass)
		data = inout_values[idx];
	
	uint scan_result = (gl_NumWorkGroups.x == 1u) ? ScanExclusive(data) : ScanInclusive(data);
	
	if (gl_GlobalInvocationID.x < pc.element_count_pass)
		inout_values[idx] = scan_result;
}