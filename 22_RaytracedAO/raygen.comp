#version 430 core
#extension GL_EXT_shader_16bit_storage : require

#include "raytraceCommon.h"
layout(local_size_x = WORKGROUP_DIM, local_size_y = WORKGROUP_DIM) in;

#include "raytraceCommon.glsl"

layout(set = 3, binding = 0) uniform usampler2D scramblebuf;
layout(set = 3, binding = 1) uniform usampler2D frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2; // should it be called backfacing or frontfacing?
layout(set = 3, binding = 2, rgba16f) restrict uniform image2D framebuffer;

bool get_sample_job()
{
	return all(lessThan(gl_GlobalInvocationID.xy,getImageDimensions(staticViewData)));
}

vec3 unpack_barycentrics(in uint data)
{
	const vec2 firstTwo = unpackUnorm2x16(data);
	return vec3(firstTwo.x,firstTwo.y,1.f-firstTwo.x-firstTwo.y);
}

void main()
{
	clear_raycount();

	uint rayMask = 0u;
	if (get_sample_job())
	{		
		// vis buffer read
		const uvec2 outPixelLocation = gl_GlobalInvocationID.xy;
		const uvec4 visBuffer = texelFetch(frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2,ivec2(outPixelLocation),0);

		const vec2 texCoordUV = (vec2(outPixelLocation)+vec2(0.5))/vec2(getImageDimensions(staticViewData));
		normalizedV = normalize(mat3(pc.cummon.viewDirReconFactors)*vec3(texCoordUV,1.f));
		
		const uint samplesPerPixelPerDispatch = bitfieldExtract(staticViewData.maxPathDepth_noRussianRouletteDepth_samplesPerPixelPerDispatch,16,16);
		Contribution contrib;
		const bool hit = visBuffer[0]!=0xffffffffu;
		if (hit)
		{
			// vis buffer decode
			const int triangleIDBitcount = findMSB(MAX_TRIANGLES_IN_BATCH-1)+1;
			const uint triangleID = bitfieldExtract(visBuffer[0],31-triangleIDBitcount,triangleIDBitcount);
			const uint batchInstanceGUID = bitfieldExtract(visBuffer[0],0,31-triangleIDBitcount);
//const vec2 compactBary = unpackUnorm2x16(visBuffer[1]);
			#ifdef TEX_PREFETCH_STREAM
			// TODO: separate pipeline and separate out the barycentric derivative FBO attachment, only write if need to, only fetch if `needs_texture_prefetch`
			const mat2 dBarydScreen = mat2(unpackHalf2x16(visBuffer[2]),unpackHalf2x16(visBuffer[3]));
			#endif
			
			//
			const nbl_glsl_ext_Mitsuba_Loader_instance_data_t batchInstanceData = InstData.data[batchInstanceGUID];
			const uvec3 indices = get_triangle_indices(batchInstanceData,triangleID);
						
			// load vertex data
			const vec3 lastVxPos = load_positions(batchInstanceData,indices);
			if (!bool(batchInstanceData.determinantSignBit&0x80000000u))
				normalizedG = -normalizedG;
			const float VdotG = dot(normalizedV,normalizedG);
			const bool frontfacing = VdotG>=0.f;

			// get material
			const nbl_glsl_MC_oriented_material_t material = nbl_glsl_MC_material_data_t_getOriented(batchInstanceData.material,frontfacing);
			contrib.color = contrib.albedo = nbl_glsl_MC_oriented_material_t_getEmissive(material,normalizedV);

			// little optimization for non-twosided materials
			if (material.genchoice_count!=0u)
			{
				// get initial scramble key
				const nbl_glsl_xoroshiro64star_state_t scramble_start_state = texelFetch(scramblebuf,ivec2(outPixelLocation),0).rg;

				vec3 origin;
				#if RECOMPUTE_BARY
					// we know the ray will intersect the triangle
					vec2 compactBary;
					{
						// reversed order of arguments for each cross cause V is negative
						const vec3 ray_cross_e2 = cross(dPdBary[1],normalizedV);
						const float detRcp = 1.f/dot(dPdBary[0],ray_cross_e2);
						// assert(!isinf(detRcp));
						const vec3 s = (pc.cummon.viewDirReconFactors[3]-lastVxPos)*detRcp;
						const float u = dot(s,ray_cross_e2);
						// assert(0.f<=u && u<=1.f)
						const vec3 s_cross_e1 = cross(s,dPdBary[0]);
						const float v = -dot(normalizedV,s_cross_e1);
						// assert(0.f<=v && v<=1.f)
						compactBary = vec2(u,v);
						//
						const float t = dot(dPdBary[1],s_cross_e1);
						//assert(t>0.f);
						origin = pc.cummon.viewDirReconFactors[3]-normalizedV*t;
					}
				#else
				const vec2 compactBary = unpackUnorm2x16(visBuffer[1]);
				#endif
				origin = dPdBary*compactBary+lastVxPos;

				//
				normalizedN = load_normal_and_prefetch_textures(
					batchInstanceData,indices,compactBary,material
					#ifdef TEX_PREFETCH_STREAM
					,dBarydScreen
					#endif
				);

				// generate rays
				const uint vertex_depth = 1u;
				rayMask = generate_next_rays(
					samplesPerPixelPerDispatch,material,frontfacing,vertex_depth,
					scramble_start_state,pc.cummon.frameLowDiscrepancySequenceShift,outPixelLocation,origin,
					vec3(pc.cummon.rcpFramesDispatched),1.f,contrib.albedo,contrib.worldspaceNormal
				);
			}
			else
				contrib.worldspaceNormal = normalizedG*nbl_glsl_MC_colorToScalar(contrib.albedo);
		}
		else
			Contribution_initMiss(contrib,1.f);

		if (bool(bitfieldExtract(pc.cummon.pathDepth_rayCountWriteIx,0,RAYCOUNT_SHIFT)))
		{
			Contribution_normalizeAoV(contrib);
		
			// we could optimize this, but its pointless before using KHR_ray_query
			const bool firstFrame = pc.cummon.rcpFramesDispatched==1.f;
			const float luma = nbl_glsl_MC_colorToScalar(contrib.color);
			for (uint i=0u; i<samplesPerPixelPerDispatch; i++)
			{
				const uvec3 coord = uvec3(outPixelLocation,i);

				if (isRWMCEnabled())
				{
					nbl_glsl_RWMC_SplattingParameters splat = nbl_glsl_RWMC_getCascade(staticViewData.cascadeParams,luma);

					// ray out of ray-payload, using first layer of accumulation texture to store emissive along path so far
					const bool pathToBeContinued = bool((rayMask>>i)&0x1u);
					if (pathToBeContinued)
					{
						storeAccumulation(contrib.color*pc.cummon.rcpFramesDispatched,coord);
						splat.cascadeWeights = vec2(0.f,0.f);
					}

					const uint higherCascade = splat.lowerCascade+1u;
					const uint cascadeCount = staticViewData.cascadeParams.penultimateCascadeIx+2u;
					for (uint cascadeIx=0u; cascadeIx<cascadeCount; cascadeIx++)
					{
						float weight = 0.f;
						if (cascadeIx==splat.lowerCascade)
							weight = splat.cascadeWeights[0];
						else if (cascadeIx==higherCascade)
							weight = splat.cascadeWeights[1];
						nextSampleAccumulationCascade(
							firstFrame,contrib.color*weight,coord,samplesPerPixelPerDispatch,
							cascadeIx,pc.cummon.rcpFramesDispatched
						);
					}
				}

				const bool hideEnvmap = bool(staticViewData.sampleSequenceStride_hideEnvmap>>31);
				// clear accumulations totally if beginning a new frame
				if (firstFrame)
				{
					if (!isRWMCEnabled())
						storeAccumulation(contrib.color,coord);
					storeAlbedo(contrib.albedo,coord);
					storeWorldspaceNormal(contrib.worldspaceNormal,coord);
					storeMask(hideEnvmap&&(!hit) ? 1.f:0.f,coord);
				}
				else
				{
					if (!isRWMCEnabled())
					{
						const vec3 prev = fetchAccumulation(coord);
						const vec3 delta = (contrib.color-prev)*pc.cummon.rcpFramesDispatched;
						if (any(greaterThan(abs(delta),vec3(exp2(-19.f)))))
							storeAccumulation(prev+delta,coord);
					}
					addAlbedo(contrib.albedo,coord,pc.cummon.rcpFramesDispatched);
					addWorldspaceNormal(contrib.worldspaceNormal,coord,pc.cummon.rcpFramesDispatched);
					if (hideEnvmap)
						addMask(hit ? 0.f:1.f,coord,pc.cummon.rcpFramesDispatched);
				}
			}
		}
		else
			imageStore(framebuffer,ivec2(outPixelLocation),vec4(contrib.albedo,1.f));
	}
}