#version 430 core

#include "common.glsl"

#include "commonIndirect.glsl"
layout(local_size_x = kCullWorkgroupSize) in;

layout(set = 1, binding = 0, std430, row_major) restrict writeonly buffer PerDraw
{
    DrawData_t drawData[];
};
layout(set = 1, binding = 1, std430) restrict writeonly buffer IndirectDraws
{
    DrawElementsIndirectCommand_t draws[];
};
layout(set = 1, binding = 2, std430, row_major) restrict readonly buffer PerInstance
{
    ModelData_t modelData[];
};

layout(push_constant) uniform PushConstants
{
    CullShaderData_t data;
} pc;


void main()
{
    uint drawID = gl_GlobalInvocationID.x;
    if (drawID<pc.data.maxDrawCount)
        return;

    mat4x3 worldMatrix = irr_builtin_glsl_workaround_AMD_broken_row_major_qualifier_mat4x3(modelData[drawID].worldMatrix);
    mat4 MVP;
    for (int i=0; i<4; i++)
        MVP[i] = pc.data.viewProjMatrix[0]*worldMatrix[0][i]+pc.data.viewProjMatrix[1]*worldMatrix[1][i]+pc.data.viewProjMatrix[2]*worldMatrix[2][i];
    MVP[3] += pc.data.viewProjMatrix[3];

    //vec3 minEdge = modelData[drawID].bbox[0];
    //vec3 maxEdge = modelData[drawID].bbox[1];

    bool culled = false;
    if (pc.data.cull!=0u)
    {
        culled = true;
    }

    draws[drawID].instanceCount = culled ? 0u:1u;
    if (!culled)
    {
        drawData[drawID].modelViewProjMatrix = MVP;
        drawData[drawID].normalMatrix = pc.data.viewInverseTransposeMatrix*irr_builtin_glsl_workaround_AMD_broken_row_major_qualifier_mat3x3(modelData[drawID].normalMatrix);
    }
}
