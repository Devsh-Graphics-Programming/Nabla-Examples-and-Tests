layout(local_size_x = 16, local_size_y = 16) in;


#if BINNING_METHOD==0

uint getAtomicOffset() {return 0u;}

#elif BINNING_METHOD==1

//output to separate global atomic per CU (guessed)

#elif BINNING_METHOD==2


#extension GL_NV_shader_thread_group: require
//output to separate global atomic per SM

#elif BINNING_METHOD==3

#extension GL_ARB_shader_ballot: require

//use mbcnt+dump to separate global atomic per CU (guess which CU from work group)

#elif BINNING_METHOD==4

#extension GL_NV_shader_thread_group: require
//use mbcnt+dump to separate global atomic per SM

#elif BINNING_METHOD==5

//use mbcnt+shared atomics and then output to same global atomic

#elif BINNING_METHOD==6

#extension GL_NV_shader_thread_group: require
//use mbcnt+shared atomics and then output to same global atomic

#elif BINNING_METHOD==7

//use mbcnt+shared reduction and then output to same global atomic

#elif BINNING_METHOD==8

#extension GL_NV_shader_thread_group: require
//use mbcnt+shared reduction and then output to same global atomic

#endif // BINNING_METHOD


uniform uint optimizerKillerOffset;


layout(std430, binding = 0) restrict buffer OutputAtomicData {
	uint packedHistogram[];
};


//! No shared memory atomics used on purpose!

void main()
{
#if BINNING_METHOD==9
    packedHistogram[optimizerKillerOffset] = 1u;
#else
    atomicAdd(packedHistogram[optimizerKillerOffset+getAtomicOffset()],1u);
#endif // BINNING_METHOD
}

