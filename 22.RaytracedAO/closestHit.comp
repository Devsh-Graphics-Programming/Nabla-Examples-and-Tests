#version 430 core
#extension GL_EXT_shader_16bit_storage : require

#include "raytraceCommon.h"
layout(local_size_x = WORKGROUP_SIZE) in;

// TODO : NEE
#define MAX_RAYS_GENERATED 1
#include "raytraceCommon.glsl"

bool record_raytrace_emission(out vec3 acc, in uvec3 accumulationLocation, vec3 emissive)
{
	const bool later_path_vertices = accumulationLocation.z==0u||get_path_vertex_depth()!=2u;
	return record_emission_common(acc,accumulationLocation,emissive,later_path_vertices);
}


#include <nbl/builtin/glsl/ext/RadeonRays/intersection.glsl>
layout(set = 3, binding = 0, std430) restrict buffer Queries
{
	nbl_glsl_ext_RadeonRays_Intersection data[];
} intersections[2];


bool get_sample_job(in uint vertex_depth_mod_2)
{
	return gl_GlobalInvocationID.x<traceIndirect[vertex_depth_mod_2].rayCount;
}

uint get_path_vertex_depth()
{
	return bitfieldExtract(pc.cummon.samplesComputed_depth,16,16);
}

void main()
{
	const uint vertex_depth = get_path_vertex_depth();
	const uint vertex_depth_mod_2 = vertex_depth&0x1u;
	if (get_sample_job(vertex_depth))
	{
		vec3 emissive = staticViewData.envmapBaseColor;	

		// basic reads
		const nbl_glsl_ext_RadeonRays_Intersection intersection = intersections[vertex_depth_mod_2].data[gl_GlobalInvocationID.x].shapeid;
		const nbl_glsl_ext_RadeonRays_ray ray = rays[vertex_depth_mod_2].data[gl_GlobalInvocationID.x];

		const uint batchInstanceGUID = intersection.shapeid;
		const uint invalidID = 0x80000000u;
		const bool hit = batchInstanceGUID!=invalidID;

		const uvec2 outPixelLocation = unpackOutPixelLocation(ray.time);
		const vec3 throughput = vec3(
			unpackHalf2x16(ray.useless_padding[0]).rg,
			unpackHalf2x16(ray.useless_padding[1])[0]
		);
		const uint sampleID = bitfieldExtract(ray.useless_padding[1],16,16);

		//
		if (hit)
		{
			const uint triangleID = intersection.primid;
			const uvec3 indices = get_triangle_indices(batchInstanceGUID,triangleID);

			// clear the hit success flag
			intersections[vertex_depth_mod_2].data[gl_GlobalInvocationID.x].shapeid = -1;
			// obtain ray incoming direction
			normalizedV = -ray.direction;
			
			// positions
			load_positions(indices,batchInstanceGUID);
			const vec3 geomNormal = cross(dPdBary[1],dPdBary[0]);
			const bool frontfacing = dot(geomNormal,normalizedV)>0.f;

			// get material
			const nbl_glsl_MC_oriented_material_t material = nbl_glsl_MC_material_data_t_getOriented(InstData.data[batchInstanceGUID].material,frontfacing);
			emissive = nbl_glsl_MC_oriented_material_t_getEmissive(material);
	
			const uint MAX_PATH_DEPTH = 2u; // TODO: move to push constant or UBO
			const bool _continue = vertex_depth!=MAX_PATH_DEPTH && ray.maxT==FLT_INF; // last vertex or was a NEE path
			if (_continue)
			{
				// if we ever support spatially varying emissive, we'll need to hoist barycentric computation and UV fetching to the position fetching
				const vec2 compactBary = intersection.uvwt.xy;
				
				const mat2 dBarydScreen = mat2(0.0); // TODO: Covariance Rendering
				const nbl_glsl_xoroshiro64star_state_t scramble_start_state = load_aux_vertex_attrs(
					compactBary,indices,batchInstanceGUID,material,dBarydScreen,outPixelLocation,vertex_depth_mod_2
				);

				const vec3 hitWorldPos = dPdBary*compactBary.xy+positions[2];
				
				generate_next_rays(
					MAX_RAYS_GENERATED,material,frontfacing,vertex_depth_mod_2,
					scramble_start_state,sampleID,outPixelLocation,hitWorldPos,geomNormal,throughput
				);
			}
		}
		
		// TODO: finish MIS
		vec3 acc;
		const uvec3 accumulationLocation = uvec3(outPixelLocation,sampleID%staticViewData.samplesPerPixelPerDispatch);
		if (record_raytrace_emission(acc,accumulationLocation,emissive*throughput))
			storeAccumulation(acc,accumulationLocation);
	}
}