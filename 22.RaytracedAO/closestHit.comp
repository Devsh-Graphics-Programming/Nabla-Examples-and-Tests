#version 430 core
#extension GL_EXT_shader_16bit_storage : require

#include "raytraceCommon.h"
layout(local_size_x = WORKGROUP_SIZE) in;

// TODO : NEE
#define MAX_RAYS_GENERATED 1
#include "raytraceCommon.glsl"

uint get_path_vertex_depth()
{
	return bitfieldExtract(pc.cummon.pathDepth_rayCountWriteIx,0,RAYCOUNT_SHIFT);
}

#include <nbl/builtin/glsl/ext/RadeonRays/intersection.glsl>
layout(set = 3, binding = 0, std430) restrict readonly buffer SourceRays
{
	nbl_glsl_ext_RadeonRays_ray sourceRays[];
};
layout(set = 3, binding = 1, std430) restrict buffer Queries
{
	nbl_glsl_ext_RadeonRays_Intersection intersections[];
};

bool get_sample_job()
{
	return gl_GlobalInvocationID.x<rayCount[(pc.cummon.pathDepth_rayCountWriteIx-(0x1u<<RAYCOUNT_SHIFT))>>RAYCOUNT_SHIFT];
}

void main()
{
	clear_raycount();

	uint rayMask = 0u;
	if (get_sample_job())
	{
		// basic reads
		const uint vertex_depth = get_path_vertex_depth();
		const nbl_glsl_ext_RadeonRays_Intersection intersection = intersections[gl_GlobalInvocationID.x];
		const nbl_glsl_ext_RadeonRays_ray ray = sourceRays[gl_GlobalInvocationID.x];

		const uint batchInstanceGUID = intersection.shapeid;
		const uint invalidID = 0xffffffffu;
		const bool hit = batchInstanceGUID!=invalidID;
		
		// obtain ray incoming direction
		normalizedV = -ray.direction;

		//
		uvec2 outPixelLocation;
		float aovThroughputScale;
		unpackOutPixelLocationAndAoVThroughputFactor(ray.time,outPixelLocation,aovThroughputScale);
		const vec3 throughput = vec3(
			unpackHalf2x16(ray.useless_padding[0]).rg,
			unpackHalf2x16(ray.useless_padding[1])[0]
		);
		const uint sampleID = bitfieldExtract(ray.useless_padding[1],16,16);

		//
		Contribution contrib;
		if (hit)
		{
			const uint triangleID = intersection.primid;
			const nbl_glsl_ext_Mitsuba_Loader_instance_data_t batchInstanceData = InstData.data[batchInstanceGUID];
			
			// clear the hit success flag
			intersections[gl_GlobalInvocationID.x].shapeid = -1;

			const uvec3 indices = get_triangle_indices(batchInstanceData,triangleID);
			
			// positions
			const vec3 lastVxPos = load_positions(batchInstanceData,indices);
			if (!bool(batchInstanceData.determinantSignBit&0x80000000u))
				normalizedG = -normalizedG;
			const bool frontfacing = dot(normalizedV,normalizedG)>=0.f;

			// get material
			const nbl_glsl_MC_oriented_material_t material = nbl_glsl_MC_material_data_t_getOriented(batchInstanceData.material,frontfacing);
			contrib.color = contrib.albedo = nbl_glsl_MC_oriented_material_t_getEmissive(material, normalizedV);
	
			const uint maxPathDepth = bitfieldExtract(staticViewData.maxPathDepth_noRussianRouletteDepth_samplesPerPixelPerDispatch,0,8);
			const bool _continue = vertex_depth!=maxPathDepth && material.genchoice_count!=0u && ray.maxT==nbl_glsl_FLT_MAX; // not last vertex and has a BxDF and not NEE path
			if (_continue)
			{
				// if we ever support spatially varying emissive, we'll need to hoist barycentric computation and UV fetching to the position fetching
				const vec2 compactBary = vec2(1.f-intersection.uv.x-intersection.uv.y,intersection.uv.x); // radeon rays is a special boy and does its barycentrics weird
			
				//
				const nbl_glsl_xoroshiro64star_state_t scramble_start_state = nbl_glsl_xoroshiro64star_state_t(ray.mask,ray._active);
			
				//
				normalizedN = load_normal_and_prefetch_textures(
					batchInstanceData,indices,compactBary,material
			#ifdef TEX_PREFETCH_STREAM
					,mat2(0.0) // TODO: Covariance Rendering
			#endif
				);

				const vec3 origin = dPdBary*compactBary+lastVxPos;
				rayMask = generate_next_rays(
					MAX_RAYS_GENERATED,material,frontfacing,vertex_depth,
					scramble_start_state,sampleID,outPixelLocation,origin,
					throughput,aovThroughputScale,contrib.albedo,contrib.worldspaceNormal
				);
			}
			else
				contrib.worldspaceNormal = normalizedG*nbl_glsl_MC_colorToScalar(contrib.albedo);
		}
		else
			Contribution_initMiss(contrib,aovThroughputScale);
			
		Contribution_normalizeAoV(contrib);
		
		const uint samplesPerPixelPerDispatch = bitfieldExtract(staticViewData.maxPathDepth_noRussianRouletteDepth_samplesPerPixelPerDispatch,16,16);
		const uvec3 accumulationLocation = uvec3(outPixelLocation,sampleID%samplesPerPixelPerDispatch);
		// TODO: finish MIS
		contrib.color *= throughput;
		const vec3 aovThroughput = throughput*aovThroughputScale;
		//
		if (isRWMCEnabled())
		{
			const bool pathToBeContinued = bool(rayMask);
			if (pathToBeContinued)
				addAccumulation(contrib.color,accumulationLocation);
			else
			{
				// need whole path throughput when splatting
				contrib.color += fetchAccumulation(accumulationLocation);
				const nbl_glsl_RWMC_SplattingParameters splat = nbl_glsl_RWMC_getCascade(staticViewData.cascadeParams,nbl_glsl_MC_colorToScalar(contrib.color)/pc.cummon.rcpFramesDispatched);
				for (uint j=0u; j<2u; j++)
					addAccumulationCascade(
						contrib.color*splat.cascadeWeights[j],accumulationLocation,
						samplesPerPixelPerDispatch,splat.lowerCascade+j
					);
			}
		}
		else
			addAccumulation(contrib.color,accumulationLocation);
		//
		addAlbedo(contrib.albedo*aovThroughput,accumulationLocation);
		addWorldspaceNormal(contrib.worldspaceNormal*nbl_glsl_MC_colorToScalar(aovThroughput),accumulationLocation);
		// only misses contribute to transparency
		if (bool(staticViewData.sampleSequenceStride_hideEnvmap>>31))
		{
			float mask = 0.f;
			if (!hit)
			{
				// make the luma of throughput dictate transparency
				mask = dot(aovThroughput,transpose(nbl_glsl_sRGBtoXYZ)[1]);
				// only count transmissions
				const vec2 texCoordUV = (vec2(accumulationLocation.xy)+vec2(0.5))/vec2(getImageDimensions(staticViewData));
				const vec3 seeThroughDir = normalize(mat3(pc.cummon.viewDirReconFactors)*vec3(texCoordUV,1.f));
				mask *= pow(max(dot(normalizedV,seeThroughDir),0.f),1024.f);
			}
			addMask(mask,accumulationLocation);
		}
	}
}