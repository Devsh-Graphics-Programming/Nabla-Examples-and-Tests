#version 430 core
#extension GL_EXT_shader_16bit_storage : require

#include "raytraceCommon.h"
layout(local_size_x = WORKGROUP_DIM, local_size_y = WORKGROUP_DIM) in;

#include "raytraceCommon.glsl"

bool record_raster_emission(out vec3 acc, in uvec3 accumulationLocation, vec3 emissive)
{	
	emissive *= float(staticViewData.samplesPerPixelPerDispatch);
	const bool retval = record_emission_common(acc,accumulationLocation,emissive,false);
	/*
	if (pc.cummon.rcpFramesDispatched!=1.f)
		TODO: plop the accumulation into autoexposure histogram
	*/
	return retval;
}


layout(set = 3, binding = 0) uniform sampler2D depthbuf;
layout(set = 3, binding = 1) uniform usampler2D frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2; // should it be called backfacing or frontfacing?

bool get_sample_job()
{
	return all(lessThan(gl_GlobalInvocationID.xy,staticViewData.imageDimensions));
}

vec3 unpack_barycentrics(in uint data)
{
	const vec2 firstTwo = unpackUnorm2x16(data);
	return vec3(firstTwo.x,firstTwo.y,1.f-firstTwo.x-firstTwo.y);
}

void main()
{
	if (get_sample_job())
	{
		vec3 emissive = staticViewData.envmapBaseColor;

		// basic reads
		const float revdepth = texelFetch(depthbuf,ivec2(gl_GlobalInvocationID.xy),0).r;
		const uvec2 outPixelLocation = gl_GlobalInvocationID.xy;

		const bool hit = revdepth>0.0;
		if (hit)
		{
			// vis buffer read
			const uvec4 visBuffer = texelFetch(frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2,ivec2(outPixelLocation),0);
			
			// unproject
			vec3 hitWorldPos;
			{
				const vec3 NDC = vec3(vec2(outPixelLocation)*staticViewData.rcpPixelSize+staticViewData.rcpHalfPixelSize,1.0-revdepth);
				
				const vec4 tmp = nbl_glsl_pseudoMul4x4with3x1(pc.cummon.inverseMVP,NDC);
				hitWorldPos = tmp.xyz/tmp.w;

				const vec3 V = nbl_glsl_pseudoMul3x4with3x1(pc.cummon.ndcToV,NDC);
				normalizedV = normalize(V);
			}

			// vis buffer decode
			const bool frontfacing = !bool(visBuffer[0]&0x80000000u);
			const int triangleIDBitcount = findMSB(MAX_TRIANGLES_IN_BATCH-1)+1;
			const uint batchInstanceGUID = bitfieldExtract(visBuffer[0],triangleIDBitcount,31-triangleIDBitcount);
			const uint triangleID = bitfieldExtract(visBuffer[0],0,triangleIDBitcount);
			const vec2 compactBary = unpackUnorm2x16(visBuffer[1]);
			#ifdef TEX_PREFETCH_STREAM
			const mat2 dBarydScreen = mat2(unpackHalf2x16(visBuffer[2]),unpackHalf2x16(visBuffer[3]));
			#endif


			const uvec3 indices = get_triangle_indices(batchInstanceGUID,triangleID);
			
			// get material while waiting for indices
			const nbl_glsl_MC_oriented_material_t material = nbl_glsl_MC_material_data_t_getOriented(InstData.data[batchInstanceGUID].material,frontfacing);
			emissive = nbl_glsl_MC_oriented_material_t_getEmissive(material);
			
			const uint vertex_depth_mod_2 = 0x1u;
			// load vertex data
			load_positions(indices,batchInstanceGUID);
			const nbl_glsl_xoroshiro64star_state_t scramble_start_state = load_aux_vertex_attrs(
				compactBary,indices,batchInstanceGUID,material,dBarydScreen,outPixelLocation,vertex_depth_mod_2
			);

			// generate rays
			const uint sampleID = bitfieldExtract(pc.cummon.samplesComputed_depth,0,16);
			const vec3 geomNormal = -normalize(cross(dPdBary[1],dPdBary[0]));
			generate_next_rays(
				staticViewData.samplesPerPixelPerDispatch,material,frontfacing,vertex_depth_mod_2,
				scramble_start_state,sampleID,outPixelLocation,hitWorldPos,geomNormal,vec3(1.0)
			);
		}


		vec3 acc;
		const uvec3 accumulationLocation = uvec3(outPixelLocation,0u);
		if (record_raster_emission(acc,accumulationLocation,emissive))
			storeAccumulation(acc,accumulationLocation);
	}
}