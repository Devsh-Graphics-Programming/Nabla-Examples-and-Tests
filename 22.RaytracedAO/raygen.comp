#version 430 core
#extension GL_EXT_shader_16bit_storage : require

#include "raytraceCommon.h"
layout(local_size_x = WORKGROUP_DIM, local_size_y = WORKGROUP_DIM) in;


#include "raytraceCommon.glsl"

bool record_raster_emission(out vec3 acc, in uvec3 accumulationLocation, vec3 emissive)
{	
	emissive *= float(staticViewData.samplesPerPixelPerDispatch);
	const bool retval = record_emission_common(acc,accumulationLocation,emissive,false);
	/*
	if (pc.cummon.rcpFramesDispatched!=1.f)
		TODO: plop the accumulation into autoexposure histogram
	*/
	return retval;
}


layout(set = 3, binding = 0) uniform sampler2D depthbuf;
layout(set = 3, binding = 1) uniform usampler2D frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2; // should it be called backfacing or frontfacing?
layout(set = 3, binding = 2) uniform usampler2D scramblebuf_start;

bool get_sample_job(in uint vertex_depth_mod_2)
{
	return all(lessThan(gl_GlobalInvocationID.xy,staticViewData.imageDimensions));
}

vec3 unpack_barycentrics(in uint data)
{
	const vec2 firstTwo = unpackUnorm2x16(data);
	return vec3(firstTwo.x,firstTwo.y,1.f-firstTwo.x-firstTwo.y);
}

void main()
{
	if (get_sample_job())
	{
		vec3 emissive = staticViewData.envmapBaseColor;

		// basic reads
		const float revdepth = texelFetch(depthbuf,ivec2(gl_GlobalInvocationID.xy),0).r;
		const uvec2 outPixelLocation = gl_GlobalInvocationID.xy;

		const bool hit = revdepth>0.0;
		if (hit)
		{
			// vis buffer read
			const uvec4 visBuffer = texelFetch(frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2,ivec2(outPixelLocation),0);
			
			// unproject
			vec3 hitWorldPos;
			{
				const vec3 NDC = vec3(vec2(outPixelLocation)*staticViewData.rcpPixelSize+staticViewData.rcpHalfPixelSize,1.0-revdepth);
				
				const vec4 tmp = nbl_glsl_pseudoMul4x4with3x1(pc.cummon.inverseMVP,NDC);
				worldPosition = tmp.xyz/tmp.w;

				const vec3 V = nbl_glsl_pseudoMul3x4with3x1(pc.cummon.ndcToV,NDC);
				normalizedV = normalize(V);
			}

			// vis buffer decode
			const bool frontfacing = !bool(visBuffer[0]&0x80000000u);
			const int triangleIDBitcount = findMSB(MAX_TRIANGLES_IN_BATCH-1)+1;
			const uint batchInstanceGUID = bitfieldExtract(visBuffer[0],triangleIDBitcount,31-triangleIDBitcount);
			const uint triangleID = bitfieldExtract(visBuffer[0],0,triangleIDBitcount);
			const vec3 bary = nbl_glsl_barycentric_expand(unpackUnorm2x16(visBuffer[1]));
			#ifdef TEX_PREFETCH_STREAM
			const mat2 dBarydScreen = mat2(unpackHalf2x16(visBuffer[2]),unpackHalf2x16(visBuffer[3]));
			#endif


			const uvec3 indices = get_triangle_indices(batchInstanceGUID,triangleID);


			// get material while waiting for indices
			const nbl_glsl_MC_oriented_material_t material = nbl_glsl_MC_material_data_t_getOriented(InstData.data[batchInstanceGUID].material,frontfacing);
			emissive = nbl_glsl_MC_oriented_material_t_getEmissive(material);

			// init scramble while waiting for material
			const nbl_glsl_xoroshiro64star_state_t scramble_start_state = texelFetch(scramblebuf_start,ivec2(outPixelLocation),0).rg;
			

			const mat3 normals = mat3(
				nbl_glsl_fetchVtxNormal(indices[i],batchInstanceGUID),
				nbl_glsl_fetchVtxNormal(indices[i],batchInstanceGUID),
				nbl_glsl_fetchVtxNormal(indices[i],batchInstanceGUID)
			);
			#ifdef TEX_PREFETCH_STREAM
			const mat3x2 uvs = mat3x2(
				nbl_glsl_fetchVtxUV(indices[0],batchInstanceGUID),
				nbl_glsl_fetchVtxUV(indices[1],batchInstanceGUID),
				nbl_glsl_fetchVtxUV(indices[2],batchInstanceGUID)
			);
			const mat3 positions = mat3(
				nbl_glsl_fetchVtxPos(indices[0],batchInstanceGUID),
				nbl_glsl_fetchVtxPos(indices[1],batchInstanceGUID),
				nbl_glsl_fetchVtxPos(indices[2],batchInstanceGUID)
			);
			const nbl_glsl_MC_instr_stream_t tps = nbl_glsl_MC_oriented_material_t_getTexPrefetchStream(material);
			#endif
			
			const vec3 normal = normalize(normals*bary);
			normalizedN.x = dot(InstData.data[batchInstanceGUID].normalMatrixRow0,normal);
			normalizedN.y = dot(InstData.data[batchInstanceGUID].normalMatrixRow1,normal);
			normalizedN.z = dot(InstData.data[batchInstanceGUID].normalMatrixRow2,normal);
			#ifdef TEX_PREFETCH_STREAM
			dUVdBary = mat2(uvs[0]-uvs[2],uvs[1]-uvs[2]);
			dPdBary = mat2x3(positions[0]-positions[2],positions[1]-positions[2]);
			const vec3 UV = dUVdBary*bary.xy+uvs[2];
			const mat2 dUVdScreen = nbl_glsl_applyChainRule2D(dUVdBary,dBarydScreen);
			nbl_glsl_MC_runTexPrefetchStream(tps,UV,dUVdScreen);
			#endif
			
			const uint sampleID = bitfieldExtract(pc.cummon.samplesComputed_depth,0,16)+i;

			// get material streams			
			const nbl_glsl_MC_instr_stream_t gcs = nbl_glsl_MC_oriented_material_t_getGenChoiceStream(material);
			const nbl_glsl_MC_instr_stream_t rnps = nbl_glsl_MC_oriented_material_t_getRemAndPdfStream(material);

			// need to do this after we have worldspace V and N ready
			const nbl_glsl_MC_precomputed_t precomputed = nbl_glsl_MC_precomputeData(frontfacing);
			#ifdef NORM_PRECOMP_STREAM
			const nbl_glsl_MC_instr_stream_t nps = nbl_glsl_MC_oriented_material_t_getNormalPrecompStream(material);
			nbl_glsl_MC_runNormalPrecompStream(nps,precomputed);
			#endif


			#define MAX_RAYS_GENERATED 11
			// prepare rays
			uint raysToAllocate = 0u;
			float maxT[MAX_RAYS_GENERATED]; vec3 direction[MAX_RAYS_GENERATED]; vec3 nextThroughput[MAX_RAYS_GENERATED];	
			for (uint i=0u; i<staticViewData.samplesPerPixelPerDispatch; i++)
			{
				nbl_glsl_xoroshiro64star_state_t scramble_state = scramble_start_state;
				gen_sample_ray(maxT[i],direction[i],nextThroughput[i],scramble_state,sampleID+i,precomputed,gcs,rnps);
				if (i==0u)
					imageStore(scramblebuf,ivec2(outPixelLocation),uvec4(scramble_state,0u,0u));
				if (any(greaterThan(nextThroughput[i],vec3(FLT_MIN))))
					raysToAllocate++;
				else
					maxT[i] = 0.f;
			}
			const uint vertex_depth_mod_2_inv = 0x0u;
			// TODO: investigate workgroup reductions here
			const uint baseOutputID = atomicAdd(traceIndirect[vertex_depth_mod_2_inv].rayCount,raysToAllocate);
			// set up dispatch indirect
			atomicMax(traceIndirect[vertex_depth_mod_2_inv].params.num_groups_x,(baseOutputID+raysToAllocate-1u)/WORKGROUP_SIZE+1u);
			uint offset = 0u;
			for (uint i=0u; i<staticViewData.samplesPerPixelPerDispatch; i++)
			if (maxT[i]!=0.f)
			{
				nbl_glsl_ext_RadeonRays_ray newRay;
				// TODO: improve ray offsets
				const float err = frontfacing ? (1.0/128.0):(-1.0/128.0);
				newRay.origin = hitWorldPos+normal*err;
				newRay.maxT = maxT;
				newRay.direction = direction;
				newRay.time = packOutPixelLocation(outPixelLocation);
				newRay.mask = -1;
				newRay._active = 1;
				newRay.useless_padding[0] = packHalf2x16(nextThroughput[i].rg);
				newRay.useless_padding[1] = bitfieldInsert(packHalf2x16(nextThroughput[i].bb),sampleID+i,16,16);
				const uint outputID = baseOutputID+(offset++);
				rays[vertex_depth_mod_2_inv].data[outputID] = newRay;
			}
		}


		vec3 acc;
		const uvec3 accumulationLocation = uvec3(outPixelLocation,0u);
		if (record_raster_emission(acc,accumulationLocation,emissive))
			storeAccumulation(acc,accumulationLocation);
	}
}