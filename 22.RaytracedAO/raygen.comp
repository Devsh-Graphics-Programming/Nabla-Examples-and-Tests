#version 430 core
#include "raygenCommon.glsl"


#include <nbl/builtin/glsl/utils/normal_decode.glsl>
//
layout(set = 2, binding = 0, row_major) uniform RaygenData
{
	RaygenShaderData_t raygenData;
};
// rng
layout(set = 2, binding = 1) uniform usamplerBuffer sampleSequence;
layout(set = 2, binding = 2) uniform usampler2D scramblebuf;
// vis buffer
layout(set = 2, binding = 3) uniform sampler2D depthbuf;
layout(set = 2, binding = 4) uniform usampler2D objectTriangleFrontFacing;
layout(set = 2, binding = 5) uniform sampler2D encodedNormal;
layout(set = 2, binding = 6) uniform sampler2D uv;



float linearizeZBufferVal(in float nonLinearZBufferVal)
{
	// 1-(Ax+B)/(Cx) = y
	// (Ax+B)/(Cx) = 1-y
	// x = B/(C(1-y)-A)
	// x = B/(C-A-Cy)
	// get back original Z: `row[2][3]/(row[3][2]-row[2][2]-y*row[3][2]) = x`
	// max Z: `B/(C-A)`
	// positive [0,1] Z: `B/(C-A-Cy)/(B/(C-A))`
	// positive [0,1] Z: `(C-A)/(C-A-Cy)`
	// positive [0,1] Z: `D/(D-Cy)`
    return 1.0/(pc.data.depthLinearizationConstant*nonLinearZBufferVal+1.0);
}


/*
float maxAbs1(in float val) 
{
	return abs(val);
}
float maxAbs2(in vec2 val)
{
	vec2 v = abs(val);
	return max(v.x,v.y);
}
float maxAbs3(in vec3 val)
{
	vec3 v = abs(val);
	return max(max(v.x,v.y),v.z);
}

float GET_MAGNITUDE(in float val)
{
	float x = abs(val);
	return uintBitsToFloat(floatBitsToUint(x)&2139095040u);
}

float ULP1(in float val, in uint accuracy)
{
	float x = abs(val);
	return uintBitsToFloat(floatBitsToUint(x) + accuracy)-x;
}
float ULP2(in vec2 val, in uint accuracy)
{
	float x = maxAbs2(val);
	return uintBitsToFloat(floatBitsToUint(x) + accuracy)-x;
}
float ULP3(in vec3 val, in uint accuracy)
{
	float x = maxAbs3(val);
	return uintBitsToFloat(floatBitsToUint(x) + accuracy)-x;
}
*/


struct SamplingData_t
{
	uint sampleID;
};
bool gen_sample_ray(out float maxT, out vec3 direction, out vec3 throughput, in SamplingData_t samplingData)
{
	maxT = FLT_MAX;
	direction = normalize(vec3(0.5,0.5,0.5));
	throughput = vec3(1.0);
	return true;
}

#ifdef TODO
// TODO: define lower and upper bound over `lightCDF`
vec3 light_sample(out vec3 incoming, in uint sampleIx, in uint scramble, inout float maxT, inout bool alive, in vec3 position)
{
	uint lightIDSample = ugen_uniform_sample1(0u,sampleIx,scramble);
	vec2 lightSurfaceSample = gen_uniform_sample2(2u,sampleIx,scramble);

	uint lightID = upper_bound(lightIDSample,uint(lightCDF.length()-1));

	SLight light = light[lightID];

#define SHADOW_RAY_LEN 0.93
	float factor; // 1.0/light_probability already baked into the light factor
	switch (SLight_extractType(light))
	{
		case SLight_ET_ELLIPSOID:
			lightSurfaceSample.x = lightSurfaceSample.x*2.0-1.0;
			{
				mat4x3 tform = light.transform;
				float equator = lightSurfaceSample.y*2.0*kPI;
				vec3 pointOnSurface = vec3(vec2(cos(equator),sin(equator))*sqrt(1.0-lightSurfaceSample.x*lightSurfaceSample.x),lightSurfaceSample.x);
	
				incoming = mat3(tform)*pointOnSurface+(tform[3]-position);
				float incomingInvLen = inversesqrt(dot(incoming,incoming));
				incoming *= incomingInvLen;

				maxT = SHADOW_RAY_LEN/incomingInvLen;

				factor = 4.0*kPI; // compensate for the domain of integration
				// don't normalize, length of the normal times determinant is very handy for differential area after a 3x3 matrix transform
				vec3 negLightNormal = light.transformCofactors*pointOnSurface;

				factor *= max(dot(negLightNormal,incoming),0.0)*incomingInvLen*incomingInvLen;
			}
			break;
		default: // SLight_ET_TRIANGLE:
			{
				vec3 pointOnSurface = transpose(light.transformCofactors)[0];
				vec3 shortEdge = transpose(light.transformCofactors)[1];
				vec3 longEdge = transpose(light.transformCofactors)[2];

				lightSurfaceSample.x = sqrt(lightSurfaceSample.x);

				pointOnSurface += (shortEdge*(1.0-lightSurfaceSample.y)+longEdge*lightSurfaceSample.y)*lightSurfaceSample.x;

				vec3 negLightNormal = cross(shortEdge,longEdge);

				incoming = pointOnSurface-position;
				float incomingInvLen = inversesqrt(dot(incoming,incoming));
				incoming *= incomingInvLen;

				maxT = SHADOW_RAY_LEN/incomingInvLen;

				factor = 0.5*max(dot(negLightNormal,incoming),0.0)*incomingInvLen*incomingInvLen;
			}
			break;
	}

	if (factor<FLT_MIN)
		alive = false;

	return light.factor*factor;
}
#endif

void main()
{
	uvec2 outputLocation = gl_GlobalInvocationID.xy;
	if (all(lessThan(outputLocation,pc.data.imageDimensions)))
	{
		ivec2 uv = ivec2(outputLocation);
		float revdepth = texelFetch(depthbuf,uv,0).r;

		uint outputID = outputLocation.y*pc.data.samplesPerRowPerDispatch+outputLocation.x;

		SamplingData_t samplingData;
		// unproject
		vec3 viewDir;
		vec3 position;
		{
			const mat4x3 frustumCorners = pc.data.frustumCorners;
			const vec2 NDC = vec2(outputLocation)*pc.data.rcpPixelSize+pc.data.rcpHalfPixelSize;

			viewDir = mix(frustumCorners[0]*NDC.x+frustumCorners[1],frustumCorners[2]*NDC.x+frustumCorners[3],NDC.yyy);
			position = viewDir*linearizeZBufferVal(revdepth)+pc.data.cameraPosition;
		}
		
		bool alive = false;
		uint scramble,objectID,triangleID;
		bool backfacing;
		vec3 normal = vec3(0.0);
		vec2 uvCoord;
		if (revdepth>0.0)
		{
			scramble = texelFetch(scramblebuf,uv,0).r;

			alive = true;
		}
#ifdef USE_OPTIX_DENOISER
		// TODO: translate normal into float16_t buff
#endif

		for (uint i=0u; i<pc.data.samplesPerPixelPerDispatch; i++)
		{
			vec3 direction; // TODO: just use nbl_glsl_LightSample?
			float maxT;
			vec4 throughput = vec4(0.0,0.0,0.0,-1.0); // -1 needs to be there to ensure no backface culling on rays

			bool validRay = false;
			if (alive)
			{
				samplingData.sampleID = pc.data.samplesComputedPerPixel+i;
				validRay = gen_sample_ray(maxT,direction,throughput.rgb,samplingData);
			}
			
			// TODO: repack rays in smem for coalescing
			const uint realOutputID = outputID+i;
			if (validRay)
			{
				rays[realOutputID].origin = position;/*+newray.direction*err?; TODO */
				rays[realOutputID].maxT = 0.0;
				rays[realOutputID].direction = direction;
				rays[realOutputID].mask = -1;
				rays[realOutputID]._active = 1;
				rays[realOutputID].backfaceCulling = int(packHalf2x16(throughput.ab));
				rays[realOutputID].useless_padding = int(packHalf2x16(throughput.gr));
			}
			else
			{
				rays[realOutputID].maxT = 0.0;
				rays[realOutputID].mask = 0;
				rays[realOutputID]._active = 0;
			}
		}
	}
}