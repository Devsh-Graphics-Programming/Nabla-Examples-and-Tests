#version 430 core
#include "raytraceCommon.glsl"

// for per pixel inputs
#include <nbl/builtin/glsl/random/xoroshiro.glsl>
#include <nbl/builtin/glsl/utils/transform.glsl>

// rng
layout(set = 3, binding = 0) uniform usamplerBuffer sampleSequence;
layout(set = 3, binding = 1) uniform usampler2D scramblebuf;
// vis buffer
layout(set = 3, binding = 2) uniform sampler2D depthbuf;
layout(set = 3, binding = 3) uniform usampler2D frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2; // should it be called backfacing or frontfacing?
layout(set = 3, binding = 4) readonly restrict buffer ExtraBatchData
{
	uint firstIndex[];
} extraBatchData;

#include "bin/material_declarations.glsl"
#include <nbl/builtin/glsl/ext/MitsubaLoader/material_compiler_compatibility_impl.glsl>
vec3 normalizedV;
vec3 nbl_glsl_MC_getNormalizedWorldSpaceV()
{
	return normalizedV;
}
vec3 normalizedN;
vec3 nbl_glsl_MC_getNormalizedWorldSpaceN()
{
	return normalizedN;
}
mat2x3 dPdBary;
mat2x3 nbl_glsl_perturbNormal_dPdSomething()
{
	return dPdBary;
}
mat2 dUVdBary;
mat2 nbl_glsl_perturbNormal_dUVdSomething()
{
    return dUVdBary;
}
#define _NBL_USER_PROVIDED_MATERIAL_COMPILER_GLSL_BACKEND_FUNCTIONS_
#include <nbl/builtin/glsl/material_compiler/common.glsl>


vec3 rand3d(inout nbl_glsl_xoroshiro64star_state_t scramble_state, in uint _sample)
{
	uvec3 seqVal = texelFetch(sampleSequence,int(_sample)).xyz;
	seqVal ^= uvec3(nbl_glsl_xoroshiro64star(scramble_state),nbl_glsl_xoroshiro64star(scramble_state),nbl_glsl_xoroshiro64star(scramble_state));
    return vec3(seqVal)*uintBitsToFloat(0x2f800004u);
}

void gen_sample_ray(
	out float maxT, out vec3 direction, out vec3 throughput,
	inout nbl_glsl_xoroshiro64star_state_t scramble_state, in uint sampleID,
	in nbl_glsl_MC_precomputed_t precomp, in nbl_glsl_MC_instr_stream_t gcs, in nbl_glsl_MC_instr_stream_t rnps
)
{
	maxT = FLT_MAX;
	
	vec3 rand = rand3d(scramble_state,sampleID);
	
	float pdf;
	nbl_glsl_LightSample s;
	throughput = nbl_glsl_MC_runGenerateAndRemainderStream(precomp, gcs, rnps, rand, pdf, s);
	throughput /= float(staticViewData.samplesPerPixelPerDispatch);

	direction = s.L;
}

void main()
{
	uvec2 outputLocation = gl_GlobalInvocationID.xy;
	if (all(lessThan(outputLocation,staticViewData.imageDimensions)))
	{
		ivec2 pixelCoord = ivec2(outputLocation);
		float revdepth = texelFetch(depthbuf,pixelCoord,0).r;

		const uint outputID = outputLocation.y*staticViewData.samplesPerRowPerDispatch+outputLocation.x*staticViewData.samplesPerPixelPerDispatch;
		
		nbl_glsl_xoroshiro64star_state_t scramble_start_state; // this should get advanced for secondary rays by 3 or 4 iterations
		
		vec3 worldPosition;
		nbl_glsl_MC_instr_stream_t gcs;
		nbl_glsl_MC_instr_stream_t rnps;
		nbl_glsl_MC_precomputed_t precomputed;

		const bool nonBackgroudPixel = revdepth>0.0;
		vec3 emissive = staticViewData.envmapBaseColor;
		if (nonBackgroudPixel)
		{			
			// vis buffer read
			const uvec4 visBuffer = texelFetch(frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2,pixelCoord,0);
			// init scramble
			scramble_start_state = texelFetch(scramblebuf,pixelCoord,0).rg;
			// unproject
			{
				const vec3 NDC = vec3(vec2(outputLocation)*staticViewData.rcpPixelSize+staticViewData.rcpHalfPixelSize,1.0-revdepth);
				
				vec4 tmp = nbl_glsl_pseudoMul4x4with3x1(pc.cummon.inverseMVP,NDC);
				worldPosition = tmp.xyz/tmp.w;

				const vec3 V = nbl_glsl_pseudoMul3x4with3x1(pc.cummon.ndcToV,NDC);
				normalizedV = normalize(V);
			}
			
			// vis buffer decode
			const int triangleIDBitcount = findMSB(MAX_TRIANGLES_IN_BATCH-1)+1;
			const bool backfacing = bool(visBuffer[0]&0x80000000u);
			const uint batchInstanceGUID = bitfieldExtract(visBuffer[0],triangleIDBitcount,31-triangleIDBitcount);
			const vec2 bary = unpackUnorm2x16(visBuffer[1]);
			#ifdef TEX_PREFETCH_STREAM
				const mat2 dBarydScreen = mat2(unpackHalf2x16(visBuffer[2]),unpackHalf2x16(visBuffer[3]));
				nbl_glsl_MC_instr_stream_t tps;
			#endif
			#ifdef NORM_PRECOMP_STREAM
				nbl_glsl_MC_instr_stream_t nps;
			#endif
			// get material
			{
				const nbl_glsl_MC_oriented_material_t material = nbl_glsl_MC_material_data_t_getOriented(InstData.data[batchInstanceGUID].material,!backfacing);
				
				// use loaded data
				emissive = nbl_glsl_MC_oriented_material_t_getEmissive(material);
				gcs = nbl_glsl_MC_oriented_material_t_getGenChoiceStream(material);
				rnps = nbl_glsl_MC_oriented_material_t_getRemAndPdfStream(material);
				#ifdef TEX_PREFETCH_STREAM
					tps = nbl_glsl_MC_oriented_material_t_getTexPrefetchStream(material);
				#endif
				#ifdef NORM_PRECOMP_STREAM
					nps = nbl_glsl_MC_oriented_material_t_getNormalPrecompStream(material);
				#endif
			}
			// vertex indices
			uvec3 indices;
			{
				const uint triangleID = bitfieldExtract(visBuffer[0],0,triangleIDBitcount);
				const uint baseTriangleVertex = triangleID*3u+extraBatchData.firstIndex[batchInstanceGUID];
				for (uint i=0u; i<3u; i++)
					indices[i] = nbl_glsl_VG_fetchTriangleVertexIndex(baseTriangleVertex,i);
			}
			// vertex attribute reads and interpolation
			vec3 normal;
			#ifdef TEX_PREFETCH_STREAM
				vec2 UV;
			#endif
			{
				mat3 normals;
				for (int i=0; i<3; i++)
					normals[i] = nbl_glsl_fetchVtxNormal(indices[i],batchInstanceGUID);
				#ifdef TEX_PREFETCH_STREAM
					mat3x2 uvs;
					for (int i=0; i<3; i++)
						uvs[i] = nbl_glsl_fetchVtxUV(indices[i],batchInstanceGUID);
					mat3 positions;
					for (int i=0; i<3; i++)
						positions[i] = nbl_glsl_fetchVtxPos(indices[i],batchInstanceGUID);
				#endif
					
				const float lastBary = 1.f-bary.x-bary.y;

				normal = normals[0]*bary.x;
				normal += normals[1]*bary.y;
				normal += normals[2]*lastBary;
				normalizedN.x = dot(InstData.data[batchInstanceGUID].normalMatrixRow0,normal);
				normalizedN.y = dot(InstData.data[batchInstanceGUID].normalMatrixRow1,normal);
				normalizedN.z = dot(InstData.data[batchInstanceGUID].normalMatrixRow2,normal);
				normalizedN = normalize(normalizedN);
				#ifdef TEX_PREFETCH_STREAM
					dUVdBary = mat2(uvs[0]-uvs[2],uvs[1]-uvs[2]);
					dPdBary = mat2x3(positions[0]-positions[2],positions[1]-positions[2]);
					
					UV = dUVdBary*bary+uvs[2];
				#endif
			}
			
			// need to do this after we have world, V and N ready
			precomputed = nbl_glsl_MC_precomputeData(!backfacing);
			// prefetch textures and normals
			#ifdef TEX_PREFETCH_STREAM
				const mat2 dUVdScreen = nbl_glsl_applyChainRule2D(dUVdBary,dBarydScreen);
				nbl_glsl_MC_runTexPrefetchStream(tps,UV,dUVdScreen);
			#endif
			#ifdef NORM_PRECOMP_STREAM
				nbl_glsl_MC_runNormalPrecompStream(nps,precomputed);
			#endif
		}
			
		//
		if (any(greaterThan(emissive,vec3(FLT_MIN))))
		{
			vec3 acc = emissive;
			if (pc.cummon.rcpFramesDispatched<1.0)
			{
				acc /= float(pc.cummon.framesDispatched-1u);
				acc += fetchAccumulation(pixelCoord);
			}
			storeAccumulation(acc,pixelCoord);
		}

		for (uint i=0u; i<staticViewData.samplesPerPixelPerDispatch; i++)
		{
			vec3 direction;
			float maxT;
			vec4 throughput = vec4(0.0,0.0,0.0,-1.0); // -1 needs to be there to ensure no backface culling on rays

			if (nonBackgroudPixel)
			{
				nbl_glsl_xoroshiro64star_state_t scramble_state = scramble_start_state;
				const uint sampleID = pc.cummon.samplesComputedPerPixel+i;
				gen_sample_ray(maxT,direction,throughput.rgb,scramble_state,sampleID,precomputed,gcs,rnps);
			}
			
			// TODO: repack rays in smem for coalescing, or optimize this somehow
			const uint realOutputID = outputID+i;
			const bool validRay = any(greaterThan(throughput.rgb,vec3(FLT_MIN)));
			if (validRay)
			{
				const float err = 1.0/64.0; // TODO: improve ray offsets
				rays[realOutputID].origin = worldPosition+direction*err;
				rays[realOutputID].maxT = max(maxT-err,0.0);
				rays[realOutputID].direction = direction;
				rays[realOutputID].mask = -1;
				rays[realOutputID]._active = 1;
			}
			else
			{
				rays[realOutputID].maxT = 0.0;
				rays[realOutputID].mask = 0;
				rays[realOutputID]._active = 0;
			}
			rays[realOutputID].backfaceCulling = int(packHalf2x16(throughput.ab));
			rays[realOutputID].useless_padding = int(packHalf2x16(throughput.gr));
		}
	}
}