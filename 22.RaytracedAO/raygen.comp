#version 430 core
#include "raytraceCommon.glsl"

// for per pixel inputs
#include <nbl/builtin/glsl/random/xoroshiro.glsl>
#include <nbl/builtin/glsl/utils/transform.glsl>

// rng
layout(set = 3, binding = 0) uniform usamplerBuffer sampleSequence;
layout(set = 3, binding = 1) uniform usampler2D scramblebuf;
// vis buffer
layout(set = 3, binding = 2) uniform sampler2D depthbuf;
layout(set = 3, binding = 3) uniform usampler2D frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2; // should it be called backfacing or frontfacing?
layout(set = 3, binding = 4) readonly restrict buffer ExtraBatchData
{
	uint firstIndex[];
} extraBatchData;

#include "bin/material_declarations.glsl"
#include <nbl/builtin/glsl/ext/MitsubaLoader/material_compiler_compatibility_impl.glsl>
vec3 normalizedV;
vec3 nbl_glsl_MC_getNormalizedWorldSpaceV()
{
	return normalizedV;
}
vec3 normalizedN;
vec3 nbl_glsl_MC_getNormalizedWorldSpaceN()
{
	return normalizedN;
}
mat2x3 dPdBary;
#ifdef TEX_PREFETCH_STREAM
mat2x3 nbl_glsl_perturbNormal_dPdSomething()
{
	return dPdBary;
}
mat2 dUVdBary;
mat2 nbl_glsl_perturbNormal_dUVdSomething()
{
    return dUVdBary;
}
#endif
#define _NBL_USER_PROVIDED_MATERIAL_COMPILER_GLSL_BACKEND_FUNCTIONS_
#include <nbl/builtin/glsl/material_compiler/common.glsl>


vec3 rand3d(inout nbl_glsl_xoroshiro64star_state_t scramble_state, in uint _sample)
{
	uvec3 seqVal = texelFetch(sampleSequence,int(_sample)).xyz;
	seqVal ^= uvec3(nbl_glsl_xoroshiro64star(scramble_state),nbl_glsl_xoroshiro64star(scramble_state),nbl_glsl_xoroshiro64star(scramble_state));
    return vec3(seqVal)*uintBitsToFloat(0x2f800004u);
}

void gen_sample_ray(
	out float maxT, out vec3 direction, out vec3 throughput,
	inout nbl_glsl_xoroshiro64star_state_t scramble_state, in uint sampleID,
	in nbl_glsl_MC_precomputed_t precomp, in nbl_glsl_MC_instr_stream_t gcs, in nbl_glsl_MC_instr_stream_t rnps
)
{
	maxT = FLT_MAX;
	
	vec3 rand = rand3d(scramble_state,sampleID);
	
	float pdf;
	nbl_glsl_LightSample s;
	throughput = nbl_glsl_MC_runGenerateAndRemainderStream(precomp, gcs, rnps, rand, pdf, s);
	throughput /= float(staticViewData.samplesPerPixelPerDispatch);

	direction = s.L;
}

uint get_path_vertex_depth()
{
	return pc.cummon.depth;
}

bool get_sample_job(out uvec2 accumulationLocation)
{
	const bool rayContinuation = get_path_vertex_depth()!=1u;
	if (rayContinuation)
	{
		//accumulationLocation = ;
		return true; // TODO: gl_GlobalInvocationID.x<raycount;
	}
	else
	{
		accumulationLocation = gl_GlobalInvocationID.xy;
		return all(lessThan(accumulationLocation,staticViewData.imageDimensions));
	}
}

void main()
{
	uvec2 accumulationLocation;
	if (get_sample_job(accumulationLocation))
	{
		const bool rayContinuation = get_path_vertex_depth()!=1u;

		uint batchInstanceGUID;
		uint triangleID;
		vec3 bary;
		bool hit;
		//
		float revdepth;
		if (rayContinuation) // read from ray query
		{
			const uint invalidID = 0x80000000u;
			batchInstanceGUID = invalidID;
			/** TODO:
			const nbl_glsl_ext_RadeonRays_Intersection isect = intersections[YYY].data[XXX];
			batchInstanceGUID = isect.shapeid;
			triangleID = isect.primid;
			bary.xy = isect.uvwt.xy;
			**/
			hit = batchInstanceGUID!=invalidID;
		}
		else // read from vis buffer
		{
			revdepth = texelFetch(depthbuf,ivec2(gl_GlobalInvocationID.xy),0).r;
			hit = revdepth>0.0;
		}

		uint raySampleID;
		vec3 emissive = staticViewData.envmapBaseColor;
		vec3 throughput = vec3(0.0);
		vec3 worldPosition,normal;
		nbl_glsl_MC_precomputed_t precomputed;
		nbl_glsl_MC_instr_stream_t gcs;
		nbl_glsl_MC_instr_stream_t rnps;
		nbl_glsl_xoroshiro64star_state_t scramble_start_state;
		if (hit)
		{
			//vec3 throughput,worldPosition;
			bool frontfacing;
			#ifdef TEX_PREFETCH_STREAM
			mat2 dBarydScreen;
			vec2 UV;
			#endif
			if (rayContinuation)
			{
				/** TODO
				raySampleID = 0u;
				thoughput.rgb = vec3(
					unpackHalf2x16(ray.useless_padding).yx,
					unpackHalf2x16(ray.backfaceCulling).yx
				);
				normalizedV = -ray.direction;
				intersections[YYY].data[XXX].shapeid = -1;
				**/
				#ifdef TEX_PREFETCH_STREAM
				dBarydScreen = mat2(0.0); // TODO: Covariance Rendering
				#endif
			}
			else
			{	
				raySampleID = 0u;
				// vis buffer read
				const uvec4 visBuffer = texelFetch(frontFacingTriangleIDDrawID_unorm16Bary_dBarydScreenHalf2x2,ivec2(gl_GlobalInvocationID.xy),0);
				throughput = vec3(1.0);
				// unproject
				{
					const vec3 NDC = vec3(vec2(gl_GlobalInvocationID.xy)*staticViewData.rcpPixelSize+staticViewData.rcpHalfPixelSize,1.0-revdepth);
				
					vec4 tmp = nbl_glsl_pseudoMul4x4with3x1(pc.cummon.inverseMVP,NDC);
					worldPosition = tmp.xyz/tmp.w;

					const vec3 V = nbl_glsl_pseudoMul3x4with3x1(pc.cummon.ndcToV,NDC);
					normalizedV = normalize(V);
				}
				// vis buffer decode
				{
					frontfacing = !bool(visBuffer[0]&0x80000000u);
					const int triangleIDBitcount = findMSB(MAX_TRIANGLES_IN_BATCH-1)+1;
					batchInstanceGUID = bitfieldExtract(visBuffer[0],triangleIDBitcount,31-triangleIDBitcount);
					triangleID = bitfieldExtract(visBuffer[0],0,triangleIDBitcount);
					bary.xy = unpackUnorm2x16(visBuffer[1]);
					#ifdef TEX_PREFETCH_STREAM
					dBarydScreen = mat2(unpackHalf2x16(visBuffer[2]),unpackHalf2x16(visBuffer[3]));
					#endif
				}
			}
			bary.z = 1.f-bary.x-bary.y;

			// vertex attribute reads and interpolation
			//vec3 normal;
			{
				// vertex indices
				uvec3 indices;
				{
					const uint baseTriangleVertex = triangleID*3u+extraBatchData.firstIndex[batchInstanceGUID];
					for (uint i=0u; i<3u; i++)
						indices[i] = nbl_glsl_VG_fetchTriangleVertexIndex(baseTriangleVertex,i);
				}
				

				// init scramble while waiting for indices
				scramble_start_state = texelFetch(scramblebuf,ivec2(accumulationLocation),0).rg;

				mat3 normals;
				for (int i=0; i<3; i++)
					normals[i] = nbl_glsl_fetchVtxNormal(indices[i],batchInstanceGUID);
				mat3 positions;
				#ifdef TEX_PREFETCH_STREAM
				mat3x2 uvs;
				for (int i=0; i<3; i++)
					uvs[i] = nbl_glsl_fetchVtxUV(indices[i],batchInstanceGUID);
				#else
				if (rayContinuation)
				#endif
				for (int i=0; i<3; i++)
					positions[i] = nbl_glsl_fetchVtxPos(indices[i],batchInstanceGUID);

				normal = normalize(normals*bary);
				normalizedN.x = dot(InstData.data[batchInstanceGUID].normalMatrixRow0,normal);
				normalizedN.y = dot(InstData.data[batchInstanceGUID].normalMatrixRow1,normal);
				normalizedN.z = dot(InstData.data[batchInstanceGUID].normalMatrixRow2,normal);
				#ifdef TEX_PREFETCH_STREAM
				dUVdBary = mat2(uvs[0]-uvs[2],uvs[1]-uvs[2]);
				UV = dUVdBary*bary.xy+uvs[2];
				#else
				if (rayContinuation)
				#endif
				dPdBary = mat2x3(positions[0]-positions[2],positions[1]-positions[2]);
				if (rayContinuation)
				{
					frontfacing = dot(cross(dPdBary[1],dPdBary[0]),normalizedV)>0.f;
					worldPosition = dPdBary*bary.xy+positions[2];
				}
			}

			// get material
			const nbl_glsl_MC_oriented_material_t material = nbl_glsl_MC_material_data_t_getOriented(InstData.data[batchInstanceGUID].material,frontfacing);
			emissive = nbl_glsl_MC_oriented_material_t_getEmissive(material);
			emissive *= throughput;
			

			// need to do this after we have worldspace V and N ready
			/*const nbl_glsl_MC_precomputed_t*/ precomputed = nbl_glsl_MC_precomputeData(frontfacing);

			/*const nbl_glsl_MC_instr_stream_t*/ gcs = nbl_glsl_MC_oriented_material_t_getGenChoiceStream(material);
			/*const nbl_glsl_MC_instr_stream_t*/ rnps = nbl_glsl_MC_oriented_material_t_getRemAndPdfStream(material);
			#ifdef TEX_PREFETCH_STREAM
			const nbl_glsl_MC_instr_stream_t tps = nbl_glsl_MC_oriented_material_t_getTexPrefetchStream(material);
			const mat2 dUVdScreen = nbl_glsl_applyChainRule2D(dUVdBary,dBarydScreen);
			nbl_glsl_MC_runTexPrefetchStream(tps,UV,dUVdScreen);
			#endif
			#ifdef NORM_PRECOMP_STREAM
			const nbl_glsl_MC_instr_stream_t nps = nbl_glsl_MC_oriented_material_t_getNormalPrecompStream(material);
			nbl_glsl_MC_runNormalPrecompStream(nps,precomputed);
			#endif
		}
		

		//
		const bool emitted = any(greaterThan(emissive,vec3(FLT_MIN)));
		const bool notFirstFrame = pc.cummon.rcpFramesDispatched<1.f;
		vec3 acc = vec3(0.0);
		if (rayContinuation || notFirstFrame)
			acc = fetchAccumulation(accumulationLocation,raySampleID);
		if (rayContinuation)
		{
			if (notFirstFrame)
				acc += (emissive-acc)*pc.cummon.rcpFramesDispatched; // wrong
			else
				acc += emissive;
		}
		else
		{
			// TODO: emissive *= float(staticViewData.samplesPerPixelPerDispatch)
			if (notFirstFrame)
				acc += emissive/float(pc.cummon.framesDispatched-1u);
			else
				acc = emissive;
		}

		const uint MAX_PATH_DEPTH = 2u;
		if (get_path_vertex_depth()!=MAX_PATH_DEPTH)
		{
			// TODO: support indirect dispatches of progressively less rays (REDO this loop)
			const uint outputID = accumulationLocation.y*staticViewData.samplesPerRowPerDispatch+accumulationLocation.x*staticViewData.samplesPerPixelPerDispatch;
			const uint continuations = rayContinuation ? 1u:staticViewData.samplesPerPixelPerDispatch;
			for (uint i=0u; i<continuations; i++)
			{
				//

				vec3 direction;
				float maxT;
				if (hit)
				{
					nbl_glsl_xoroshiro64star_state_t scramble_state = scramble_start_state;
					const uint sampleID = pc.cummon.samplesComputedPerPixel+i;

					vec3 throughputFactor;
					gen_sample_ray(maxT,direction,throughputFactor,scramble_state,sampleID,precomputed,gcs,rnps);
					throughput.rgb = throughputFactor; // TODO *= throughputFactor;

					// TODO: save the `scramble_state` for the last sample in the pixel
				}
			
				const uint realOutputID = outputID+i;
				const bool validRay = any(greaterThan(throughput.rgb,vec3(FLT_MIN)));
				// TODO: improve ray offsets
				const float err = 1.0/128.0;
				if (validRay)
					rays[realOutputID].origin = worldPosition+normal*err;
				rays[realOutputID].maxT = validRay ? maxT:0.0;
				if (validRay)
					rays[realOutputID].direction = direction;
				rays[realOutputID].mask = validRay ? (-1):0;
				rays[realOutputID]._active = validRay ? 1:0;
				// -1.f needs to be there to ensure no backface culling on rays
				rays[realOutputID].backfaceCulling = int(packHalf2x16(vec2(-1.f,throughput.b)));
				rays[realOutputID].useless_padding = int(packHalf2x16(throughput.gr));
			}
		}
			
		// TODO: finish MIS
		if (emitted || !notFirstFrame)
			storeAccumulation(acc,accumulationLocation,raySampleID);
	}
}