#version 430 core

#define WORK_GROUP_DIM 32u
layout(local_size_x = WORK_GROUP_DIM, local_size_y = WORK_GROUP_DIM) in;
#define WORK_GROUP_SIZE (WORK_GROUP_DIM*WORK_GROUP_DIM)


#include "common.glsl"


layout(push_constant, row_major) uniform PushConstants
{
	ResolveShaderData_t data;
} pc;


layout(set = 2, binding = 0, std430) restrict buffer Queries
{
	int hit[];
};





#define RAYS_IN_CACHE 1u
#define KERNEL_HALF_SIZE 0u
#define CACHE_DIM (WORK_GROUP_DIM+2u*KERNEL_HALF_SIZE)
#define CACHE_SIZE (CACHE_DIM*CACHE_DIM*RAYS_IN_CACHE)
shared uint rayScratch0[CACHE_SIZE];
shared uint rayScratch1[CACHE_SIZE];
shared float rayScratch2[CACHE_SIZE];
shared float rayScratch3[CACHE_SIZE];
shared float rayScratch4[CACHE_SIZE];

void main()
{
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	uint baseID = gl_GlobalInvocationID.x+uImageWidth_ImageArea_TotalImageSamples_Samples.x*gl_GlobalInvocationID.y;
	bool alive = all(lessThan(gl_GlobalInvocationID.xy,uImageSize));

	vec4 acc = vec4(0.0);
	if (uRcpFramesDone<1.0 && alive)
		acc = imageLoad(framebuffer,pixelCoord);

	vec3 color = vec3(0.0);
	uvec2 groupLocation = gl_WorkGroupID.xy*WORK_GROUP_DIM;
	for (uint i=0u; i<uImageWidth_ImageArea_TotalImageSamples_Samples.w; i+=RAYS_IN_CACHE)
	{
		for (uint lid=gl_LocalInvocationIndex; lid<CACHE_SIZE; lid+=WORK_GROUP_SIZE)
		{
			ivec3 coord;
			coord.z = int(lid/(CACHE_DIM*CACHE_DIM));
			coord.y = int(lid/CACHE_DIM)-int(coord.z*CACHE_DIM+KERNEL_HALF_SIZE);
			coord.x = int(lid)-int(coord.y*CACHE_DIM+KERNEL_HALF_SIZE);
			coord.z += int(i);
			coord.y += int(groupLocation.y);
			coord.x += int(groupLocation.x);
			bool invalidRay = any(lessThan(coord.xy,ivec2(0,0))) || any(greaterThan(coord,ivec3(uImageSize,uImageWidth_ImageArea_TotalImageSamples_Samples.w)));
			int rayID = coord.x+coord.y*int(uImageWidth_ImageArea_TotalImageSamples_Samples.x)+coord.z*int(uImageWidth_ImageArea_TotalImageSamples_Samples.y);
			invalidRay = invalidRay ? false:(hit[rayID]>=0);
			rayScratch0[lid] = invalidRay ? 0u:rays[rayID].useless_padding;
			rayScratch1[lid] = invalidRay ? 0u:rays[rayID].backfaceCulling;
			rayScratch2[lid] = invalidRay ? 0.0:rays[rayID].direction[0];
			rayScratch3[lid] = invalidRay ? 0.0:rays[rayID].direction[1];
			rayScratch4[lid] = invalidRay ? 0.0:rays[rayID].direction[2];
		}
		barrier();
		memoryBarrierShared();

		uint localID = (gl_LocalInvocationID.x+KERNEL_HALF_SIZE)+(gl_LocalInvocationID.y+KERNEL_HALF_SIZE)*CACHE_DIM;
		for (uint j=localID; j<CACHE_SIZE; j+=CACHE_DIM*CACHE_DIM)
		{
			vec3 raydiance = vec4(unpackHalf2x16(rayScratch0[j]),unpackHalf2x16(rayScratch1[j])).gra;
			color += raydiance;
		}

		// hit buffer needs clearing
		for (uint j=i; j<min(uImageWidth_ImageArea_TotalImageSamples_Samples.w,i+RAYS_IN_CACHE); j++)
		{
			uint rayID = baseID+j*uImageWidth_ImageArea_TotalImageSamples_Samples.y;
			hit[rayID] = -1;
		}
	}

	if (alive)
	{
		// TODO: move to ray gen, for fractional sampling?
		color *= 1.0/float(uImageWidth_ImageArea_TotalImageSamples_Samples.w);

		// TODO: optimize the color storage (RGB9E5/RGB19E7 anyone?)
		acc.rgb += (color-acc.rgb)*uRcpFramesDone;
		imageStore(framebuffer,pixelCoord,acc);
	}
}