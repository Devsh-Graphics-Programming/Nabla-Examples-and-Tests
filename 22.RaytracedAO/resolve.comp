#version 430 core
#include "raytraceCommon.glsl"


#include <nbl/builtin/glsl/ext/RadeonRays/intersection.glsl>
layout(set = 2, binding = 0, std430) restrict buffer Queries
{
	nbl_glsl_ext_RadeonRays_Intersection hits[];
};
layout(set = 2, binding = 1, r32ui) restrict uniform uimage2D framebuffer;


void main()
{
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
	const uint baseID = pixelCoord.y*staticViewData.samplesPerRowPerDispatch+pixelCoord.x*staticViewData.samplesPerPixelPerDispatch;
	if (all(lessThan(pixelCoord,staticViewData.imageDimensions)))
	{
		vec3 acc = fetchAccumulation(pixelCoord);
		
		vec3 color = vec3(0.0);
		uvec2 groupLocation = gl_WorkGroupID.xy*gl_WorkGroupSize.xy;
		for (uint i=0u; i<1u/*staticViewData.samplesPerPixelPerDispatch*/; i++)
		{
			const uint rayID = baseID+i;
			nbl_glsl_ext_RadeonRays_Intersection hit = hits[rayID];

			// actually got a hit
			if (hit.shapeid<0)
				continue;

			//color.r -= float(hit.shapeid);//staticViewData.samplesPerPixelPerDispatch;
			//color.g -= float(hit.primid);//staticViewData.samplesPerPixelPerDispatch;

			// hit buffer needs clearing
			hits[rayID].shapeid = -1;
		}
		if (pc.cummon.rcpFramesDispatched<1.0)
			acc += (color-acc)*pc.cummon.rcpFramesDispatched;
		else
			acc += color;
		storeAccumulation(acc,pixelCoord);
		acc = abs(acc);
        acc.rg /= vec2(32.0,1023.0);
		imageStore(framebuffer,pixelCoord,uvec4(nbl_glsl_encodeRGB10A2(vec4(acc,1.0)),0u,0u,0u));
	}
}