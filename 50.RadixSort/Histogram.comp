#version 450

#define TOTAL_ELEMENTS (1 << 23)
#define WG_DIM (1 << 8)
#define BITS_PER_PASS 4
#define NUM_BUCKETS (1 << BITS_PER_PASS)
#define WG_COUNT (TOTAL_ELEMENTS/WG_DIM)

layout (local_size_x = WG_DIM) in;

layout (set = 0, binding = 0, std430) readonly buffer in_buffer
{
	uvec2 in_values[];
	// uint in_values[];
};

layout (set = 0, binding = 1, std430) writeonly buffer out_buffer
{
	uint out_values[];
};

layout(push_constant) uniform pushConstants
{
    layout (offset = 0) uint shift;
} u_push_constants;

shared uint local_histogram[NUM_BUCKETS * WG_DIM]; // 16KB

void main()
{
	for (int i = 0; i < NUM_BUCKETS; i++)
		local_histogram[i * WG_DIM + gl_LocalInvocationID.x] = 0;

	// Todo: Probably remove memoryBarrier from here?
	barrier();
	memoryBarrier();

	// Todo: I don't like this boundary checking, pad with identity instead
	if (gl_GlobalInvocationID.x < TOTAL_ELEMENTS)
	{
		// uint local_key = in_values[gl_GlobalInvocationID.x].x;
		// uint digit = in_values[gl_GlobalInvocationID.x] & 0xf;
		// uint digit = (in_values[gl_GlobalInvocationID.x] >> u_push_constants.shift) & 0xf;
		uint digit = (in_values[gl_GlobalInvocationID.x].x >> u_push_constants.shift) & 0xf;
		local_histogram[digit * WG_DIM + gl_LocalInvocationID.x]++;
	}

	// Todo: Probably remove memoryBarrier from here?
	barrier();
	memoryBarrier();

	if (gl_LocalInvocationID.x < NUM_BUCKETS)
	{
		uint sum = 0;
		for (int i = 0; i < WG_DIM; ++i)
			sum += local_histogram[gl_LocalInvocationID.x * WG_DIM + (i + gl_LocalInvocationID.x) % WG_DIM];
		out_values[gl_LocalInvocationID.x * WG_COUNT + gl_WorkGroupID.x] = sum;
	}
}