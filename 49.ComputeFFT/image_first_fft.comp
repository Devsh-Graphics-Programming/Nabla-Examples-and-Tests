layout(local_size_x=_NBL_GLSL_WORKGROUP_SIZE_, local_size_y=1, local_size_z=1) in;

#define _NBL_GLSL_EXT_FFT_GET_PARAMETERS_DEFINED_
#define _NBL_GLSL_EXT_FFT_SET_DATA_DEFINED_
#define _NBL_GLSL_EXT_FFT_GET_PADDED_DATA_DEFINED_
#include "nbl/builtin/glsl/ext/FFT/fft.glsl"

// Input Descriptor
layout(set=0, binding=0) uniform sampler2D inputImage;

// output
layout(set=0, binding=1) restrict buffer OutputBuffer
{
	nbl_glsl_complex outData[];
};

// Get/Set Data Function
layout(push_constant) uniform PushConstants
{
	nbl_glsl_ext_FFT_Parameters_t params;
} pc;

 nbl_glsl_ext_FFT_Parameters_t nbl_glsl_ext_FFT_getParameters()
 {
	 nbl_glsl_ext_FFT_Parameters_t ret;
	 ret = pc.params;
	 return ret;
 }

void nbl_glsl_ext_FFT_setData(in uvec3 coordinate, in uint channel, in nbl_glsl_complex complex_value)
{
	uvec3 dimension = nbl_glsl_ext_FFT_Parameters_t_getPaddedDimensions();
	uint index = channel * (dimension.x * dimension.y * dimension.z) + coordinate.z * (dimension.x * dimension.y) + coordinate.y * (dimension.x) + coordinate.x;
	outData[index] = complex_value;
}

nbl_glsl_complex nbl_glsl_ext_FFT_getPaddedData(in uvec3 coordinate, in uint channel) 
{
	ivec2 inputImageSize = textureSize(inputImage, 0);
	vec2 normalizedCoords = (vec2(coordinate.xy) + vec2(0.5f)) / vec2(inputImageSize);
	vec4 texelValue= textureLod(inputImage, normalizedCoords, 0);
	return nbl_glsl_complex(texelValue[channel], 0.0f);
}

void main()
{
    const uint numChannels = nbl_glsl_ext_FFT_Parameters_t_getNumChannels();
	for(uint ch = 0u; ch < numChannels; ++ch)
	{
		nbl_glsl_ext_FFT(nbl_glsl_ext_FFT_Parameters_t_getIsInverse(), ch);
	}
}