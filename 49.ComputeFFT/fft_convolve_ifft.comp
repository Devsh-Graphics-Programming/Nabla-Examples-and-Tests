layout(local_size_x=_NBL_GLSL_WORKGROUP_SIZE_, local_size_y=1, local_size_z=1) in;


#include <nbl/builtin/glsl/math/complex.glsl>
// Input and Output Descriptor
layout(set=0, binding=0) buffer restrict InputOutputBuffer
{
	nbl_glsl_complex inoutData[];
};
#define _NBL_GLSL_EXT_FFT_INPUT_DESCRIPTOR_DEFINED_
#define _NBL_GLSL_EXT_FFT_OUTPUT_DESCRIPTOR_DEFINED_

layout(set=0, binding=1) uniform sampler2D NormalizedKernel[3];


#define inData inoutData
#define outData inoutData
#define _NBL_GLSL_EXT_FFT_MAIN_DEFINED_
#include "nbl/builtin/glsl/ext/FFT/default_compute_fft.comp"

shared vec2 scratch[1024];

void convolve(in uint item_per_thread_count, in uint ch) 
{
	// TODO: decouple kernel size from image size (can't get the math to work in my head)
	const uint i = bitfieldReverse(gl_WorkGroupID.x)>>(32u-11u);
	const float u = float(i)/2048.f+0.5f/512.f;

	// compile time constants
	const uint HALF_SIZE = _NBL_GLSL_SCRATCH_SHARED_SIZE_DEFINED_>>1u;
	const uint ITEMS_PER_STEP = HALF_SIZE>>_NBL_GLSL_WORKGROUP_SIZE_LOG2_;
	const uint ITEM_MASK = (item_per_thread_count-1u)>>findMSB(ITEMS_PER_STEP);
	//
	const uint hiInvocation = gl_LocalInvocationIndex&(~ITEM_MASK);
	const uint loInvocation = gl_LocalInvocationIndex&ITEM_MASK;
	uint base = 0;
	for(uint i=0u; i<=ITEM_MASK; i++,base+=_NBL_GLSL_WORKGROUP_SIZE_*ITEMS_PER_STEP)
	{
		const float base_v = float(base)/1024.f+0.5f/512.f;
		barrier();
		for (uint j=0u; j<ITEMS_PER_STEP; j++)
		{
			const uint tid = _NBL_GLSL_WORKGROUP_SIZE_*j+gl_LocalInvocationIndex;
			float v = float(tid)/1024.f+base_v;
			nbl_glsl_complex tmp = textureLod(NormalizedKernel[ch],vec2(u,v),0).xy;
			_NBL_GLSL_SCRATCH_SHARED_DEFINED_[tid] = floatBitsToUint(tmp.x);
			_NBL_GLSL_SCRATCH_SHARED_DEFINED_[HALF_SIZE+tid] = floatBitsToUint(tmp.y);
		}
		barrier();
		if(loInvocation==i)
		for(uint t=0u; t<item_per_thread_count; t++)
		{
			const uint j = bitfieldReverse(_NBL_GLSL_WORKGROUP_SIZE_*t+hiInvocation)>>(32u-10u);
			nbl_glsl_complex sourceSpectrum = nbl_glsl_ext_FFT_impl_values[t];
			nbl_glsl_complex convSpectrum = nbl_glsl_complex(
				uintBitsToFloat(_NBL_GLSL_SCRATCH_SHARED_DEFINED_[j]),
				uintBitsToFloat(_NBL_GLSL_SCRATCH_SHARED_DEFINED_[HALF_SIZE+j])
			);
			nbl_glsl_ext_FFT_impl_values[t] = nbl_glsl_complex_mul(sourceSpectrum,convSpectrum);
		}
	}
}

void main()
{
    const uint log2FFTSize = nbl_glsl_ext_FFT_Parameters_t_getLog2FFTSize();
    const uint item_per_thread_count = 0x1u<<(log2FFTSize-_NBL_GLSL_WORKGROUP_SIZE_LOG2_);
	
	for(uint ch=0u; ch<=nbl_glsl_ext_FFT_Parameters_t_getMaxChannel(); ++ch)
	{
		// Load Values into local memory
		for(uint t=0u; t<item_per_thread_count; t++)
		{
			const uint tid = (t<<_NBL_GLSL_WORKGROUP_SIZE_LOG2_)|gl_LocalInvocationIndex;
			nbl_glsl_ext_FFT_impl_values[t] = nbl_glsl_ext_FFT_getPaddedData(nbl_glsl_ext_FFT_getCoordinates(tid),ch);
		}
		nbl_glsl_ext_FFT_preloaded(false,log2FFTSize);

		convolve(item_per_thread_count,ch);
	
		barrier();
		nbl_glsl_ext_FFT_preloaded(true,log2FFTSize);
		// write out to main memory
		for(uint t=0u; t<item_per_thread_count; t++)
		{
			const uint tid = (t<<_NBL_GLSL_WORKGROUP_SIZE_LOG2_)|gl_LocalInvocationIndex;
			nbl_glsl_ext_FFT_setData(nbl_glsl_ext_FFT_getCoordinates(tid),ch,nbl_glsl_ext_FFT_impl_values[t]);
		}
	}
}