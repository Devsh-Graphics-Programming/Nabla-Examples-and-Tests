#version 430 core
layout(local_size_x=16, local_size_y=16, local_size_z=1) in;
 
#include "nbl/builtin/glsl/math/complex.glsl"

layout(set=0, binding=0) restrict readonly buffer InBuffer
{
	nbl_glsl_complex in_data[];
};

layout(set=0, binding=1, rg16f) uniform image2D NormalizedKernel[3];

void main()
{
// TODO: push constants
	const uvec2 log2_sizes = findMSB(gl_WorkGroupSize*gl_NumWorkGroups).xy;
	const uvec3 strides = uvec3(1u,0x1u<<log2_sizes.x,0x1u<<(log2_sizes.x+log2_sizes.y));

	const float power = length(in_data[0]);
	nbl_glsl_complex value = in_data[gl_GlobalInvocationID.x*strides.x+gl_GlobalInvocationID.y*strides.y+gl_GlobalInvocationID.z*strides.z]/power;
	

	uvec2 coord = bitfieldReverse(gl_GlobalInvocationID.xy)>>(uvec2(32u)-log2_sizes);
	const nbl_glsl_complex shift = nbl_glsl_expImaginary(-float(coord.x+coord.y)*nbl_glsl_PI); // TODO: does this shift go away later?
	value = nbl_glsl_complex_mul(value,shift);
	imageStore(NormalizedKernel[gl_WorkGroupID.z],ivec2(coord),vec4(value,0.0,0.0));
}